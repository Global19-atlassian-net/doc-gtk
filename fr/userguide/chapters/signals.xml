<?xml version="1.0" encoding="ISO-8859-1" ?>
<chapter id="signals">
 <title>Signaux et Rappels</title>
 <sect1 id="signals.intro"></sect1>

 <sect1 id="signals.whatare">
  <title>Qu'est-ce qu'un signal?</title>
  <simpara>
   <emphasis>un signal est un événement émis par un
   <link linkend="widgets.whatare">widget</link>.</emphasis>
  </simpara>
  <simpara>
   Quand on programme une interface graphique (<acronym>GUI</acronym>), 
   on doit souvent répondre aux actions de l'utilisateur sur l'interface.
   <acronym>GNOME</acronym> et <acronym>GTK+</acronym> utilisent les signaux. 
   Les signaux sont utilisés pour savoir lorsqu'un événement se produit sur
   l'interface. Par exemple, un utilisateur qui clique sur un 
   <classname>GtkButton</classname>, ou un changement de la valeur d'un 
   <classname>GtkAdjustment</classname>.
  </simpara>
  <simpara>
   Une interface contenant un objet <classname>GtkAdjustment</classname> 
   qui enverra un signal <signalname>value-changed</signalname> quand une des 
   valeurs d'ajustement du widget changera. Ce signal particulier est utilisé
   à l'intéreur et à l'extérieur de l'objet 
   <classname>GtkAdjustment</classname>, donc il n'est pas nécessaire de
   réécrire cette fonction dans la partie de votre programme qui gère un
   objet de type <classname>GtkProgressBar</classname> (La classe 
   <classname>GtkProgressBar</classname> nécéssite un objet de type 
   <classname>GtkAdjustment</classname> comme paramètre de son constructeur).
   Par exemple, quand un utilisateur clique sur un bouton (objet 
   <classname>GtkButton</classname>) le bouton émet un signal de type 
   <signalname>clicked</signalname>. Le développeur devra alors programmer le 
   <link linkend="callbacks.whatare">rappel</link> correspondant au signal
   émis.
  </simpara>
 </sect1>

 <sect1 id="callbacks.whatare">
  <title>Qu'est-ce que les rappels?</title>
  <simpara>
   <emphasis>
    Les rappels sont les fonctions qui sont appelés quand un  
    <link linkend="signals.whatare">signal</link> est émis par un 
    <link linkend="widgets.whatare">widget</link>.
   </emphasis>
  </simpara>
  <simpara>
   Les rappels sont les fonctions définies par le développeur et qui réagissent
   aux événements emis par le widget. Pour définir la fonction qui doit être
   appelée, il faut définir la <link linkend="signals.connection">connexion</link> 
   entre la fonction et le signal.
  </simpara>
  <simpara>
   Les rappels sont aussi appellés fonctions événements  Les rappels peuvent
   être soit des <literal>événements par défaut</literal> soit des 
   <literal>évenements définis par l'utilisateur</literal> mais dans tous les
   cas c'est une fonction standard.
  </simpara>
 </sect1>

 <sect1 id="signals.inheritance">
  <title>Héritage des signaux</title>
  <simpara>
   Les signaux sont hérités par les objets au même titre que les méthodes. un
   widget peut émettre un signal défini par ses ancêtres comme si le signal
   était le sien.
  </simpara>
  <simpara>
   Si le signal n'est pas approprié au widget mais s'il en hérite, il n'y
   aura pas de message d'erreur lors de l'émission du signal car il n'y a pas
   de moyen que le widget connaisse ce signal.
  </simpara>
 </sect1>

 <sect1 id="signals.connection">
  <title>Connecter un signal</title>

  <sect2 id="signals.connection.simple">
   <title>Une connexion simple</title>
   <simpara>
    Pour que le widget réagisse, vous devez connecter le signal au rappel
    correspondant. Cette fonction est appellée par PHP-GTK lorsque le signal
    est émis.
   </simpara>
   <simpara>
    Pour connecter une fonction à un signal, il suffit d'appeller la méthode 
    <function class="GtkObject">connect</function> de l'objet.
   </simpara>
   <simpara>
    La fonction que vous venez d'enregistrer comme rappel doit avoir le bon
    prototype. Les prototypes se trouvent dans la 
    <link linkend="reference">référence</link> de ce manuel.
   </simpara>
   <simpara>
    Dans le cas du signal <signalname>clicked</signalname> pour un objet de
    type <classname>GtkButton</classname>, vous devez définir une fonction qui
    accepte un paramètre et dans ce cas le paramètre doit être le bouton qui
    sera cliqué.
   </simpara>
   <para>
    Le code qui suit montre la méthode pour créer une fenêtre, ajouter un
    bouton et lancer la boucle qui va attendre l'émission du signal. Quand le
    signal sera émis, une autre <classname>GtkWindow</classname> s'ouvrira et
    contiendra un message.
    <example>
     <title>Signals et rappels</title>
     <programlisting role="php">
<![CDATA[
<?php

function shutdown() 
{
    print(&quot;Shutting down...\n&quot;);
    gtk::main_quit();
}

function you_clicked($button) 
{
    $window = &amp;new GtkWindow();
    $label = &amp;new GtkLabel(&quot;Vouz avez appuyé sur le bouton&quot;);
    $window-&gt;add($label);
    $window-&gt;connect(&quot;destroy&quot;,&quot;shutdown&quot;);
    $window-&gt;show_all();
    return false;
}

$window = &amp;new GtkWindow();
$window-&gt;connect(&quot;destroy&quot;, &quot;shutdown&quot;);
$window-&gt;set_border_width(10);

$button = &amp;new GtkButton(&quot;Appuyez ici!!&quot;);
$button-&gt;connect(&quot;clicked&quot;, &quot;you_clicked&quot;);
$window-&gt;add($button);

$window-&gt;show_all();

gtk::main();

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    La partie la plus importante est la suivante
    <literal>$button-&gt;connect();</literal>
    la méthode connect enregistre la fonction <literal>you_clicked()</literal> 
    comme rappel et sera invoqué quand le signal 
    <signalname>clicked</signalname> est émis sur le widget
    <classname>GtkButton</classname>. Il faut également enregister la
    fonction <literal>shutdown()</literal> comme fonction événement pour le
    signal <signalname class="GtkObject">destroy</signalname> des 2 fenêtres
    pour terminer l'application correctement.
   </para>
  </sect2>

  <sect2 id="signals.connection.multiple">
   <title>Les connexions multiples</title>
   <simpara>
    En utilisant PHP-GTK, vous pouvez inscrire plusieurs méthodes pour être
    appelées lorsqu'un signal est émis sur un widget. On peux ainsi inscrire un
    certain nombre de méthodes pour répondre à un même signal émis par le
    même widget.
   </simpara>
   <para>
    Quand plusieurs fonctions sont connectées à un signal, lors de l'émission
    du signal, les méthodes seront appelées dans l'ordre de leur inscription.
    <example>
     <title>Ordre des rappels du signal</title>
   <programlisting role="php">
<![CDATA[
<?php

function first($button) 
{
    print &quot;Premier appel !\n&quot;;
}

function second($button) 
{
    print &quot;Second appel !\n&quot;;
}

$window = &amp;new GtkWindow();
$window-&gt;connect_object(&quot;destroy&quot;, array(&quot;gtk&quot;, 
&quot;main_quit&quot;));

$button = &amp;new GtkButton(&quot;Clicquez Ici!!&quot;);
$button-&gt;connect(&quot;clicked&quot;,&quot;first&quot;);
$button-&gt;connect(&quot;clicked&quot;,&quot;second&quot;);
$window-&gt;add($button);

$window-&gt;show_all();

gtk::main();

?>
]]>
     </programlisting>
    </example>
    Dans l'exemple précédent, nous connectons 2 fonctions sur le signal 
    <signalname>clicked</signalname> du bouton. Le premier appel à la
    fonction <function class="GtkObject">connect</function> connecte le
    signal <signalname class="GtkButton">clicked</signalname> à la fonction 
    <literal>first()</literal>, le second connecte le signal 
    <signalname class="GtkButton">clicked</signalname> à la fonction 
    <literal>second()</literal>.
   </para>
   <para>
    La sortie du programme donnera:
    <screen>
Premier appel !
Second appel !
    </screen>
   </para>
  </sect2>
 </sect1>
 
 <sect1 id="signals.custom.params">
  <title>Paramètres personnalisé</title>
  <sect2 id="signals.custom.data">
   <title>Passer des données en paramètre</title>
   <simpara>
    Lors de la <link linkend="signals.connection">connexion</link>
    d'un signal, il est possible d'ajouter un paramètre personnalisé aux
    rappels. Cela peut être trés utile pour passer un objet en paramêtre et
    ainsi effectuer une action sur celle-ci.
   </simpara>
   <simpara>
    Par exemple, quand on presse sur un bouton, on aimerait détruire
    l'instance de la fenetre <classname>GtkWindow</classname> qui contient
    l'instance du bouton <classname>GtkButton</classname>.
   </simpara>
   <simpara>
    Il est possible d'ajouter un troisième paramêtre à la méthode 
    <function class="GtkObject">connect</function>. Ce paramêtre sera passé
    comme dernier paramêtre à la fonction rappel.
   </simpara>
   <para>
    <example>
     <title>
      Utilisation des paramêtres personnalisés avec la méthode 
      <function class="GtkObject">connect</function>.
     </title>
   <programlisting role="php">
<![CDATA[
<?php

function button_clicked($button, $window) 
{
    $window-&gt;destroy();
    gtk::main_quit();
}

$window = &amp;new GtkWindow();

$button = &amp;new GtkButton(&quot;exit&quot;);
$button-&gt;connect(&quot;clicked&quot;,&quot;button_clicked&quot;, $window);

$window-&gt;add($button);
$window-&gt;show_all();

gtk::main();

?>
]]>
     </programlisting>
    </example>
    Dans la portion de code précédente, on passe en paramêtre au signal 
    <signalname>clicked</signalname> l'objet <literal>$button</literal>, une
    instance de <classname>GtkButton</classname>, mais aussi l'objet 
    <literal>$window</literal>, une instance de 
    <classname>GtkWindow</classname>. Ceci nous permet de détruire la
    fenêtre par l'appel de la fonction 
    <function class="GtkObject">destroy</function>.
   </para>
   <note>
    <simpara>
     Vous pouvez passer autant de paramêtres que vous voulez.
    </simpara>
   </note>
   <para>
    En passant l'objet <literal>$button</literal> comme paramêtre principal
    et <literal>$window</literal> comme paramêtre personnalisé, 
    on pourrait utiliser le même rappel pour plusieurs objets 
    <classname>GtkButton</classname> sur plusieurs fenêtres 
    <classname>GtkWindow</classname>. Il faut noter que les noms donnés aux 
    paramêtres à l'intérieur du rappel ne sont pas effectifs à l'extérieur
    du rappel. PHP-GTK reprend les positions des paramètres de la méthode et
    passe ces derniers aux variables énumérées dans la déclaration du rappel
    sous la forme d'un tableau, ainsi les connections qui utilisent les mêmes
    paramêtres peuvent utiliser la même fonction rappel. Dans l'exemple
    suivant, vous pourrez voir le cas d'utilisation du meme rappel pour
    plusieurs objets avec un seul paramêtre supplémentaire mais cet exemple
    est valable pour plusieurs paramêtres supplémentaires.
    <example>
     <title>Utiliser le même rappel pour plusieurs fenêtres</title>
     <programlisting role="php">
<![CDATA[
<?php

function button_clicked($button, $window)
{
    $window->set_title(&quot;titled&quot;);
}

$window1 = &amp;new GtkWindow();
$window1-&gt;connect_object(&quot;destroy&quot;, array(&quot;gtk&quot;, 
&quot;main_quit&quot;));
$window2 = &amp;new GtkWindow();
$window2-&gt;connect_object(&quot;destroy&quot;, array(&quot;gtk&quot;, 
&quot;main_quit&quot;));

$button1 = &amp;new GtkButton(&quot;click me&quot;);
$button2 = &amp;new GtkButton(&quot;or me&quot;);

$button1-&gt;connect(&quot;clicked&quot;, &quot;button_clicked&quot;, 
$window1);
$button2-&gt;connect(&quot;clicked&quot;, &quot;button_clicked&quot;, 
$window2);

$window1-&gt;add($button1);
$window2-&gt;add($button2);

$window1-&gt;show_all();
$window2-&gt;show_all();

gtk::main();

?>
]]>
     </programlisting>
    </example>
   </para>
  </sect2>
 
  <sect2 id="signals.connect.object">
   <title>Utilisation de la méthode connect_object*</title>
   <para>
    les méthodes <function class="GtkObject">connect_object</function> et 
    <function class="GtkObject">connect_object_after</function> vous
    permettent de remplacer l'objet qui appelle la méthode par un autre objet
    en tant que premier paramêtre du rappel. Ce qui est particulièrement
    utile lors de l'utilisation de fonction interne de PHP-GTK, par exemple la
    fonction <literal>gtk::main_quit()</literal>:
    <example>
     <title>
      Utilisation de la méthode 
      <function class="GtkObject">connect_object</function> pour spécifier
      une fonction interne comme rappel.
     </title>
     <programlisting role="php">
<![CDATA[
<?php

$window = &amp;new GtkWindow();
$window-&gt;connect_object(&quot;destroy&quot;, array(&quot;gtk&quot;, 
&quot;main_quit&quot;));
$window-&gt;show();

gtk::main();

?>
]]>
     </programlisting>
    </example>
    L'appel peut se faire sur toutes les fonctions ou méthodes statiques
    en utilisant la syntaxe <literal>gtkobject::method</literal> sous forme
    d'un tableau.
   </para>
   <para>
    Cela signifie que vous pouvez gérer plusieurs signaux avec un seul rappel. 
    Par exemple, vous pouvez créer une fenêtre qui contient (avec le conteneur
    approprié) une <classname>GtkMenuBar</classname>, une 
    <classname>GtkToolbar</classname> et un <classname>GtkButton</classname>. 
    Quand l'utilisateur choisit de <literal>quitter</literal> l'application
    à partir d'un des widgets, une fonction d'arrêt peut etre appelée en
    passant une instance d'objet <classname>GtkWindow</classname> comme
    premier paramêtre, permettant ainsi de détruire la fenêtre à partir de
    toutes les connexions. Par exemple:
    <example>
     <title>
      Utilisation de la méthode 
      <function class="GtkObject">connect_object</function> pour passer un
      autre objet.
     </title>
     <programlisting role="php">
<![CDATA[
<?php

function destroy_window($window)
{
    $window-&gt;destroy();
    gtk::main_quit();
}

$exit_button-&gt;connect_object(&quot;clicked&quot;, 
&quot;destroy_window&quot;, $window);

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    La méthode connect_after*  permet d'éxécuter le rappel &quot;aprés&quot;
    le signal par défaut. Cela peut être utile dans certaines situations.
    Par exemple, si vous voulez détruire une seule fenêtre dans une certaine
    circonstance. Cependant, les methodes connect_after* ne marcheront que si
    le signal a été crée avec le flag <literal>GTK_RUN_LAST</literal>. Le 
    signal <signalname>destroy</signalname> ainsi que tous les autres signaux
    <literal>'événement'</literal> possèdent ce flag. Deux méthodes pour savoir
    si le signal possède ce flag: faire un test avec PHP-GTK ou alors lire le
    source de GTK.
    <example> 
     <title>Utilisation de la méthode 
      <function class="GtkObject">connect_after</function>.
     </title>
     <programlisting role="php">
<![CDATA[
<?php

function quit_routine($window) 
{
    print(&quot;Shutting down...\n&quot;);
    gtk::main_quit();
}

$window1 = &amp;new GtkWindow();
$window1->set_title(&quot;Quit the main loop&quot;);
$window1-&gt;connect(&quot;destroy&quot;, &quot;quit_routine&quot;);

$window2 = &amp;new GtkWindow();
$window2->set_title(&quot;Destroy this window&quot;);
$window2-&gt;connect_after(&quot;destroy&quot;, &quot;quit_routine&quot;);

$window1-&gt;show();
$window2-&gt;show();

gtk::main();

?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    See also: <classname>GtkObject</classname>, 
    <function class="GtkObject">connect_after</function>
    <function class="GtkObject">connect_object</function> and 
    <function class="GtkObject">connect_object_after</function>.
   </simpara>
  </sect2>
 </sect1>

 <sect1 id="signals.events">
  <title>Signaux et evénements</title>
  <simpara>
   <emphasis>Les signaux GTK, les événements GDK.</emphasis>
  </simpara>
  <simpara>
   Un signal n'est pas un événement et inversement. Un signal est un message 
   émis par un <classname>GtkObject</classname> en fonction d'éléments 
   prédeterminés de son environement (une action de l'utilisateur ou une 
   instruction venant d'une méthode ou d'une fonction). Les signaux sont 
   toujours définis dans le code, soit en interne dans GTK ou alors dans
   votre application.
  </simpara>
  <simpara>
   Les évenements sont représentés par un flux de messages sur l'etat de 
   l'environnement. La boucle principale de GTK contient ces évenements.
  </simpara>
  <note>
   <simpara>
    Il n'est pas possible de connecter directement un rappel à un 
    événement <classname>GdkEvent</classname>.
   </simpara>
  </note>
  <simpara>
   Chaque widget possédant un objet <classname>GdkWindow</classname> peut
   capturer les événements qui lui sont associés. Les widgets sans 
   <classname>GdkWindow</classname> - ceux créent avec l'option 
   <literal>GTK_NO_WINDOW</literal> - ne peuvent pas recevoir les évenements
   à moins d'utiliser l'objet <classname>GtkEventBox</classname> - un widget
   creé a cet effet. Il existe des occasions où il est très utile de
   capturer les événements; par exemple, la création d'une instance de 
   <classname>GtkToolTips</classname> est déclenchée lorsque le widget
   capture l'événement <literal>GDK_ENTER_NOTIFY</literal> et détruit lorqu'il
   recoit l'événement <literal>GDK_LEAVE_NOTIFY</literal>.
  </simpara>
  <simpara>
   Il est également impossible d'utiliser l'évenement pour déclencher un
   rappel comme le ferait un signal, il existe une série de signal dérivée
   de l'objet <classname>GtkWidget</classname>, connue sous le nom de 
   <literal>signaux événements</literal>. Il est possible de définir un 
   événement comme un signal en permettant à un rappel d'être déclenché lors
   de la capture de l'événement <enumname>GdkEventTypes</enumname>. L'objet 
   <classname>GtkTooltips</classname> utilise la méthode 
   <function class="GktObject">connect_object</function> et le signal
   générique <signalname>event</signalname> sur le widget.
  </simpara>
  <para>
   Le concept d'événement n'est pas facile à comprendre.  Pour mieux
   comprendre, éxécuter ce script pour voir les différents événements en
   action.
   <example>
    <title>Démonstration du flux d'événements sur un 
     <classname>GtkButton</classname>
    </title>
   <programlisting role="php">
<![CDATA[
<?php

dl(&quot;php_gtk.&quot; . (strstr(PHP_OS, &quot;WIN&quot;) ? &quot;dll&quot; : 
&quot;so&quot;)) || die(&quot;Can't load php_gtk module!\n&quot;);

function show_event_type($button, $event, $text) 
{
    $event_type = $event-&gt;type;
    $insert = $text->get_length();
    $text-&gt;freeze();
    switch($event_type) {
      case 2:
        $text-&gt;insert_text(&quot;GDK_EXPOSE\n&quot;, $insert);
      break;
      case 3:
        $text-&gt;insert_text(&quot;GDK_MOTION_NOTIFY\n&quot;, $insert);
      break;
      case 4:
        $text-&gt;insert_text(&quot;GDK_BUTTON_PRESS\n&quot;, $insert);
      break;
      case 5:
        $text-&gt;insert_text(&quot;GDK_2BUTTON_PRESS\n&quot;, $insert);
        $button-&gt;hide();
      break;
      case 7:
        $text-&gt;insert_text(&quot;GDK_BUTTON_RELEASE\n&quot;, $insert);
      break;
      case 8:
        $text-&gt;insert_text(&quot;GDK_KEY_PRESS\n&quot;, $insert);
      break;
      case 9:
        $text-&gt;insert_text(&quot;GDK_KEY_RELEASE\n&quot;, $insert);
      break;
      case 10:
        $text-&gt;insert_text(&quot;GDK_ENTER_NOTIFY\n&quot;, $insert);
      break;
      case 11:
        $text-&gt;insert_text(&quot;GDK_LEAVE_NOTIFY\n&quot;, $insert);
      break;
      case 12:
        $text-&gt;insert_text(&quot;GDK_FOCUS_CHANGE\n&quot;, $insert); 
      break;
      case 14:
        $text-&gt;insert_text(&quot;GDK_MAP\n&quot;, $insert);
      break;
      case 15:
        $text-&gt;insert_text(&quot;GDK_UNMAP\n&quot;, $insert);
        $button-&gt;destroy();
        $text->insert_text(
&quot;\n* EVENEMENTS GDK ET SIGNAUX SIGNALS - flux vs message *
\n
* Le plupart des GdkEventTypes ont un équivalent dans les signaux GTK, les
  événements signaux, implémentés dans l'objet GtkWidget. Les types que vous
  voyez sont là car l'objet GtkButton a été programmé pour émettre des
  signaux événements génériques à chaque fois qu'ils sont capturés sur le flux
  des événements GDK events. Dans chacun des cas, l'événement GdkEvent
  capturé a été passé en paramètre du rappel et ainsi les types énumérés
  peuvent être détérminés dans la fonction signal. Scrollez vers le bas pour
  voir une série d'événements récents générés par votre interaction avec le
  widget GtkButton. *
\n
* Il faut noter que la majorité des signaux GTK ne correpondent pas aux événements
  GDK! Par exemple, la connexion au signal suivante
                      \$button->connect('pressed', 'whatever');
  n'a pas de relation avec l'événement GDK_BUTTON_PRESS, qui fait référence
  à l'action sur le bouton de la souris et non pas au signal 'pressed' sur
  l'objet GtkButton. *
\n&quot;, 0);
      break;
    }
    $text-&gt;thaw();
    return false;
}

$window = &amp;new GtkWindow();
$window-&gt;set_position(GTK_WIN_POS_CENTER);
$window-&gt;set_default_size((gdk::screen_width()/1.5), 
(gdk::screen_height()-20));
$window-&gt;connect_object(&quot;destroy&quot;, array(&quot;gtk&quot;, 
&quot;main_quit&quot;));
$window-&gt;realize();

$box = &amp;new GtkVBox(false, 5);
$window-&gt;add($box);
$scrlwin = &amp;new GtkScrolledWindow();
$box-&gt;pack_start($scrlwin, true, true, 0);
$text = &amp;new GtkText();
$scrlwin-&gt;add($text);

$button = &amp;new GtkButton(&quot;Double Cliquez ici pour plus 
d'informations..&quot;);
$button-&gt;add_events(GDK_ALL_EVENTS_MASK);
$button-&gt;connect(&quot;event&quot;, &quot;show_event_type&quot;, $text);
$box-&gt;pack_end($button, false, false, 5);

$window-&gt;show_all();

gtk::main();

?>
]]>
    </programlisting>
   </example>
  </para>
 </sect1>

</chapter> 
