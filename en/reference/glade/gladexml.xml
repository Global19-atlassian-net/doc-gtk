<?xml version="1.0" encoding="ISO-8859-1" ?>
<classentry id="glade.gladexml">
 <classmeta>
  <classtitle>GladeXML</classtitle>
  <classparent>GtkData</classparent>
  <shortdesc>
   Loading XML GUI definition files on the fly
  </shortdesc>
  <desc>
   <simpara>
    <emphasis>Glade</emphasis> is a user interface builder for Gtk.
    With it you can create your the surface of your applications
    in a WYSIWYG manner withouth having to worry about commands
    like <function class="GtkContainer">add</function>,
    <function class="GtkBox">pack_start</function> and
    <function class="GtkBox">pack_end</function>.
   </simpara>
   <simpara>
    Glade has the ability to generate source code
    which creates the whole interface - but only for C, C++ and
    Ada95. Another way of using the interfaces created with glade
    is to load the <filename>.glade</filename> files dynamically from the application
    with the <classname>GladeXML</classname> class, and PHP-Gtk 
    supports this.
   </simpara>
   <para>
    When using glade in your PHP-Gtk applications, you have
    at least 2 files:
    <itemizedlist>
     <listitem>
      Your <filename>.phpw</filename> application with the php code
     </listitem>
     <listitem>
      A <filename>.glade</filename> file which contains the 
      user interface definition
     </listitem>
    </itemizedlist>
    When starting the program, the glade class is used to load the full
    contents (if you designed the full UI in glade) or only a part of 
    the user interface (if you e.g. created just the menus with glade)
    from the <filename>.glade</filename> file. After loading, 
    the widgets behave the same 
    as if they were created the "normal" way.
   </para>
   <simpara>
    Single widgets can be accessed with the
    <function class="GladeXML">get_widget</function> functions.
    Signals which can be assigned directly in Glade can be connected
    automatically with 
    <function class="GladeXML">signal_autoconnect</function>.
   </simpara>
   <simpara>
    The original glade application can be found at
    <ulink url="http://glade.gnome.org">glade.gnome.org</ulink> and
    a windows port at 
    <ulink url="http://wingtk.sourceforge.net">wingtk.sourceforge.net</ulink>.
    There is also a tool called 
    <ulink url="http://www.cweiske.de/phpgtk_appwizard.htm">AppWizard</ulink>
    which creates the php framework from <filename>.glade</filename> files 
    so that you can concentrate
    on implementing the real application functions.
   </simpara>
   <note>
    PHP-Gtk 1.x supports glade 1 files only. This means you can not use
    Glade2 for user interface creation but Glade1.
   </note>
  </desc>
 </classmeta>

 <constructor id="glade.gladexml.constructor">
  <funcsynopsis>
   <funcprototype>
    <funcdef> <function>GladeXML</function></funcdef>
    <paramdef>string <parameter>fname</parameter></paramdef>
    <paramdef>string <parameter><optional>root = NULL</optional></parameter></paramdef>
    <paramdef>string <parameter><optional>domain = NULL</optional></parameter></paramdef>
   </funcprototype>
  </funcsynopsis>
  <shortdesc>
   Creates a new GladeXML instance.
  </shortdesc>
  <desc>
   <simpara>
    Creates a new instance of the glade class, based on a glade file 
    <parameter>fname</parameter>.
   </simpara>
   <simpara>
    If you want to load the whole glade file, you can omit the 
    <parameter>root</parameter> parameter. For loading only a part
    of the file, e.g. the menu definition, you can pass the name of
    the wished root element. In the example we could use 
    "btnClose" to load the close button only. If the button
    had subwidgets, they would be loaded as well.
   </simpara>
   <simpara>
    When using the GNU Gettext module for internationalization,
    you can specifiy the gettext <parameter>domain</parameter>
    as third parameter. Glade will translate all the properties
    marked with "translatable" via the gettext functions on this
    domain.
    <!-- @fixme: LINK TO php-gtk-gettext tutorial -->
   </simpara>
  
   <simpara>
    The following two files result in a sample application which
    loads the glade file and connect the button's 
    <signalname class="GtkButton">clicked</signalname> 
    signal to exit the application. You don't need to call the
    <function class="GtkWidget">show</function> and
    <function class="GtkWidget">realize</function> functions
    as glade takes care of this.
   </simpara>
   <example>
    <title>Basic application which loads a glade file</title>
    <programlisting role="php">
<![CDATA[
<?php
if( !extension_loaded('gtk')) { 
    dl( 'php_gtk.' . PHP_SHLIB_SUFFIX);
}

$glade =& new GladeXML( dirname( __FILE__) . "/hellowg.glade");
                     
$dlgHello = $glade->get_widget( 'dlgHellow');
$dlgHello->connect_object( 'destroy', array( 'gtk', 'main_quit'));

$btnClose = $glade->get_widget( 'btnClose');
$btnClose->connect_object( 'clicked', array( 'gtk', 'main_quit'));       

gtk::main();
?>
]]>
    </programlisting>
   </example>
   
   <example>
    <title>Basic glade file "hellowg.glade"</title>
    <programlisting role="xml">
<![CDATA[
<?xml version="1.0"?>
<GTK-Interface>

<project>
  <name>example-gladexml.constructor</name>
  <program_name>example-gladexml.constructor</program_name>
  <directory></directory>
  <source_directory>src</source_directory>
  <pixmaps_directory>pixmaps</pixmaps_directory>
  <language>C</language>
  <gnome_support>False</gnome_support>
  <gettext_support>False</gettext_support>
</project>

<widget>
  <class>GtkWindow</class>
  <name>dlgHellow</name>
  <title>Hello World!</title>
  <type>GTK_WINDOW_TOPLEVEL</type>
  <position>GTK_WIN_POS_NONE</position>
  <modal>False</modal>
  <allow_shrink>False</allow_shrink>
  <allow_grow>True</allow_grow>
  <auto_shrink>False</auto_shrink>

  <widget>
    <class>GtkVBox</class>
    <name>vbox1</name>
    <homogeneous>False</homogeneous>
    <spacing>0</spacing>

    <widget>
      <class>GtkLabel</class>
      <name>lblHello</name>
      <label>Hello world!
This is the example program
for the GladeXML class</label>
      <justify>GTK_JUSTIFY_CENTER</justify>
      <wrap>False</wrap>
      <xalign>0.5</xalign>
      <yalign>0.5</yalign>
      <xpad>0</xpad>
      <ypad>0</ypad>
      <child>
	<padding>0</padding>
	<expand>True</expand>
	<fill>True</fill>
      </child>
    </widget>

    <widget>
      <class>GtkButton</class>
      <name>btnClose</name>
      <can_focus>True</can_focus>
      <signal>
	<name>clicked</name>
	<handler>test</handler>
	<last_modification_time>Sun, 29 Aug 2004 10:33:10 GMT</last_modification_time>
      </signal>
      <label>Close this window</label>
      <relief>GTK_RELIEF_NORMAL</relief>
      <child>
	<padding>0</padding>
	<expand>False</expand>
	<fill>False</fill>
      </child>
    </widget>
  </widget>
</widget>

</GTK-Interface>
]]>
    </programlisting>
   </example>
   
   <note>
    When defining more than one window in the glade file, 
    all windows are shown when loading it. You can set
    the "Visible" property in glade to avoid this.
   </note>
   
   <simpara> 
    A small explanation of the code above: The glade code was
    automatically created with glade. The instantiation of the
    glade requires the filename as first parameter, and we use
    <command>dirname( __FILE__) . '/hellow.glade'</command> to
    make sure the glade file is loaded from the same location
    where the php script is located. If you would pass the filename
    without the parameter to the glade constructor, the glade file
    wouldn't be found if the program is run in a working directory
    which is not the directory of the php script.
    To let the application exit tidily, we connect the
    <signalname class="GtkObject">destroy</signalname> signal
    of the window as normal; but before we get the widget
    via the <function class="GladeXML">get_widget</function>
    function.
   </simpara>
  </desc>
 </constructor>

 <methods>

<!-- this method should be used internally only, so don't explain it
  <method id="glade.gladexml.method.construct">
   <funcsynopsis>
    <funcprototype>
     <funcdef>bool <function>construct</function></funcdef>
     <paramdef>string <parameter>fname</parameter></paramdef>
     <paramdef>string <parameter>root</parameter></paramdef>
     <paramdef>string <parameter>domain</parameter></paramdef>
    </funcprototype>
   </funcsynopsis>
   <shortdesc>

   </shortdesc>
   <desc>
signal_autoconnect
   </desc>
  </method>
-->


  <method id="glade.gladexml.method.get_widget">
   <funcsynopsis>
    <funcprototype>
     <funcdef><classname>GtkWidget</classname> <function>get_widget</function></funcdef>
     <paramdef>string <parameter>name</parameter></paramdef>
    </funcprototype>
   </funcsynopsis>
   <shortdesc>
    Returns the widget with the given name.
   </shortdesc>
   <desc>
    <simpara>
     Returns the widget with the given name, so that it can be
     accessed as if it were constructed directly. In the example,
     you would just have to pass "btnClose" to get the close button.
    </simpara>
    <simpara>
     The function returns NULL if the widget does not exist.
    </simpara>
    <simpara>
     The counterpart to this function is 
     <link linked="glade.method.get_widget_name">get_widget_name()</link>.
    </simpara>
   </desc>
  </method>

  <method id="glade.gladexml.method.get_widget_by_long_name">
   <funcsynopsis>
    <funcprototype>
     <funcdef><classname>GtkWidget</classname> <function>get_widget_by_long_name</function></funcdef>
     <paramdef>string <parameter>path</parameter></paramdef>
    </funcprototype>
   </funcsynopsis>
   <shortdesc>
    Returns the widget specified by the given path.
   </shortdesc>
   <desc>
    <simpara>
     Returns the widget specified by the given <parameter>path</parameter>,
     so that it can be accessed normally. Other than with
     <function class="GladeXML">get_widget</function> you don't
     pass the name but the full path with all parent widget names,
     separated by periods. In the example you get the close
     button with "dlgHellow.vbox1.btnClose".
    </simpara>
    <simpara>
     The function returns NULL if the widget does not exist.
    </simpara>
    <simpara>
     The counterpart to this function is 
     <link linked="glade.method.get_widget_long_name">get_widget_long_name()</link>.
    </simpara>
   </desc>
  </method>

  <method id="glade.gladexml.method.signal_connect">
   <funcsynopsis>
    <funcprototype>
     <funcdef>void <function>signal_connect</function></funcdef>
     <paramdef>string <parameter>handler</parameter></paramdef>
     <paramdef>mixed <parameter>callback</parameter></paramdef>
     <paramdef>mixed <parameter><optional>user_param</optional></parameter></paramdef>
    </funcprototype>
   </funcsynopsis>
   <shortdesc>
    Connects all signals with the given handler to a callback function.
   </shortdesc>
   <desc>
    <simpara>
     Connects all signals with the given handler to a callback function.
    </simpara>
    <simpara>
     In glade, you can "connect" signals to 
     "handlers". These handlers can be named like 
     functions but not necessarily have to be: When using this
     <function class="GladeXML">signal_connect</function> function
     you can connect the handler "clicker" to a function
     called "test". When using 
     <function class="GladeXML">signal_autoconnect</function> this
     is not possible as glade connects only handlers to functions
     of the same name as the handler.
    </simpara>
    <para>
     Try to extend the example with the following (after glade
     instantiation and before gtk_main):
     <programlisting role="php">
<![CDATA[
function tester()
{
    echo 'test' . "\r\n";
}
$glade->signal_connect( 'test', 'tester');
]]>
     </programlisting>
     If you click the close button now, you will see an "test" 
     output line in the shell prompt.
    </para>
    <simpara>
     You can pass any type and number of additional parameters 
     to the callback function. Note that the first parameter
     will be the calling widget.
    </simpara>
   </desc>
  </method>

  <method id="glade.gladexml.method.signal_connect_object">
   <funcsynopsis>
    <funcprototype>
     <funcdef>void <function>signal_connect_object</function></funcdef>
     <paramdef>string <parameter>handler</parameter></paramdef>
     <paramdef>mixed <parameter>callback</parameter></paramdef>
     <paramdef>mixed <parameter><optional>user_param</optional></parameter></paramdef>
    </funcprototype>
   </funcsynopsis>
   <shortdesc>
    Connects all signals with the given handler to a callback function.
   </shortdesc>
   <desc>
    <simpara>
     Connects all signals with the given handler to a callback function.
     Other than <function class="GladeXML">signal_connect</function> the
     calling widget will not be passed as the first parameter (just omitted).
    </simpara>
   </desc>
  </method>

  
  <method id="glade.gladexml.method.signal_autoconnect">
   <funcsynopsis>
    <funcprototype>
     <funcdef>void <function>signal_autoconnect</function></funcdef>
     <paramdef>array <parameter><optional>unknown</optional></parameter></paramdef>
    </funcprototype>
   </funcsynopsis>
   <shortdesc>
    Connects all signal handlers to functions.
   </shortdesc>
   <desc>
    <simpara>
     Connects all signal handlers defined in the glade file to functions
     with the same name as the signal handler.
    </simpara>
    <simpara>
     In the example, the "clicked" signal of the close button
     would be connected to a function called "test" if it 
     exists in the source.
    </simpara>
    <para>
     Try to extend the example with the following (after glade
     instantiation and before gtk_main):
     <programlisting role="php">
<![CDATA[
function test()
{
    echo 'test' . "\r\n";
}
$glade->signal_autoconnect();
]]>
     </programlisting>
     If you click the close button now, you will see an "test" 
     output line in the shell prompt.
    </para>
    <simpara>
     The first parameter passed to the callback will be the
     calling widget.
    </simpara>
   </desc>
  </method>

  <method id="glade.gladexml.method.signal_autoconnect_object">
   <funcsynopsis>
    <funcprototype>
     <funcdef>void <function>signal_autoconnect_object</function></funcdef>
     <paramdef>array <parameter><optional>unknown</optional></parameter></paramdef>
    </funcprototype>
   </funcsynopsis>
   <shortdesc>
    Connects all signal handlers to functions.
   </shortdesc>
   <desc>
    <simpara>
     Connects all signal handlers defined in the glade file to functions
     with the same name as the signal handler.
     Other than <function class="GladeXML">signal_autoconnect</function> the
     calling widget will not be passed as the first parameter (just omitted).
    </simpara>
   </desc>
  </method>
  
  <method id="glade.gladexml.method.relative_file">
   <funcsynopsis>
    <funcprototype>
     <funcdef>string <function>relative_file</function></funcdef>
     <paramdef>string <parameter>filename</parameter></paramdef>
    </funcprototype>
   </funcsynopsis>
   <shortdesc>
    Creates an absolute filename from a relative one.
   </shortdesc>
   <desc>
    <simpara>
     Creates an absolute filename from a relative one.
     The new filename will be absolute to the directory of
     the <filename>.glade</filename> file. If the filename
     was absolute, it stays untouched.
    </simpara>
    <simpara>
     Example: The <filename>.glade</filename> file is located at
     <filename>/data/php/gtk/test.glade</filename> and you pass
     "window.xpm" to this function, the result will be
     <filename>/data/php/gtk/window.xpm</filename>.
    </simpara>
   </desc>
  </method>

 </methods>

</classentry>
