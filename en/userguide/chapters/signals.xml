<?xml version="1.0" encoding="ISO-8859-1" ?>
<!-- $Revision: 1.20 $ -->
<chapter id="signals">
 <title>Signals and Callbacks</title>
 <sect1 id="signals.intro"></sect1>

 <sect1 id="signals.whatare">
  <title>What are Signals?</title>
  <simpara>
   <emphasis>Signals are notifications emitted by
   <link linkend="widgets.whatare">widgets</link>.</emphasis>
  </simpara>
  <simpara>
   When programming Graphical User Interfaces (<acronym>GUI</acronym>), 
   it is often necessary to respond to actions performed by the user or
   initiated within the program itself.  <acronym>GNOME</acronym> 
   and <acronym>GTK+</acronym> do this via the use of signals.  Signals are
   used to let the program know that something happened. This might be, for
   example, a user clicking on a <classname>GtkButton</classname>,
   or a change being made to a <classname>GtkAdjustment</classname> value.
  </simpara>
  <simpara>
   A program may, for instance, cause <classname>GtkAdjustment</classname>
   to emit its <signalname>value-changed</signalname> signal when a widget
   changes one of its adjustment values.  This particular signal is used both
   internally and externally in <classname>GtkAdjustment</classname>, so that
   it is not always necessary to write that signal into your code for, say, a
   <classname>GtkProgressBar</classname> to use it.  A more obvious situation
   may occur when a user clicks on an instance of 
   <classname>GtkButton</classname>, causing the button widget to emit the 
   <signalname>clicked</signalname> signal.  As a programmer, you can set up
   <link linkend="callbacks.whatare">callbacks</link> to react to any
   signal emitted by a widget.
  </simpara>
 </sect1>

 <sect1 id="callbacks.whatare">
  <title>What are Callbacks?</title>
  <simpara>
   <emphasis>
    Callbacks are functions that are invoked when 
    <link linkend="signals.whatare">signals</link> are emitted by
    <link linkend="widgets.whatare">widgets</link>.
   </emphasis>
  </simpara>
  <simpara>
   Callbacks are functions that are set up by the programmer to react to
   signals emitted by widgets.  You specify the function that should be
   called by <link linkend="signals.connection">connecting</link> the
   function to the signal.
  </simpara>
  <simpara>
   The callback is also known as the signal handler function.  This can be
   either the widget's <literal>default handler</literal> or a 
   <literal>user-defined handler</literal>, that is, a function written by
   the programmer.
  </simpara>
 </sect1>

 <sect1 id="signals.inheritance">
  <title>Signal Inheritance</title>
  <simpara>
   Signals are inherited by objects, just as methods are.  A widget can
   emit any signals that its ancestor objects have defined, as well as its
   own specific signals.
  </simpara>
  <simpara>
   In cases where the signal is not relevant to the widget but is nonetheless
   inherited by it, there will be no error message when the signal is called 
   - but equally, there will be no obvious means for the widget to emit that
   particular signal.
  </simpara>
 </sect1>

 <sect1 id="signals.connection">
  <title>Connecting Signals</title>

  <sect2 id="signals.connection.simple">
   <title>Simple Connections</title>
   <simpara>
    To react to a signal you must connect to it by specifying a callback
    function for PHP-GTK to call when that signal is emitted.
   </simpara>
   <simpara>
    Connecting a function to a signal is achieved by calling the
    <function class="GtkObject">connect</function> method of the object.
   </simpara>
   <simpara>
    The function that you register as the callback for a signal must have the
    correct prototype. You can find what the prototype should be from the
    <link linkend="reference">reference</link> section of this manual.
   </simpara>
   <simpara>
    For example, if you wanted to connect to the
    <signalname>clicked</signalname> signal of an instance of 
    <classname>GtkButton</classname> you should define a function that
    accepts one parameter, which will be the button that was clicked.
   </simpara>
   <para>
    The code below shows how you might create a window, add a button to it,
    wait for it to be clicked and then, when it is clicked, open a new
    <classname>GtkWindow</classname> containing a message.
    <example>
     <title>Signals and Callbacks</title>
     <programlisting role="php">
<![CDATA[
<?php
if( !extension_loaded('gtk')) {	
    dl( 'php_gtk.' . PHP_SHLIB_SUFFIX); 
}

function shutdown() 
{
    print("Shutting down...\n");
    gtk::main_quit();
}

function you_clicked($button) 
{
    $window = &new GtkWindow();
    $label = &new GtkLabel("You clicked the button");
    $window->add($label);
    $window->connect("destroy","shutdown");
    $window->show_all();
    return false;
}

$window = &new GtkWindow();
$window->connect("destroy", "shutdown");
$window->set_border_width(10);

$button = &new GtkButton("Click Me!!");
$button->connect("clicked", "you_clicked");
$window->add($button);

$window->show_all();

gtk::main();

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    The important part here is where we call
    <literal>$button-&gt;connect();</literal>
    The connect method here registers the <literal>you_clicked()</literal> 
    function as the callback that will be invoked when the 
    <signalname>clicked</signalname> signal is emitted by the 
    <classname>GtkButton</classname> widget.  We also register the 
    <literal>shutdown()</literal> function as the handler for the 
    <signalname>destroy</signalname> signal for both windows so that we
    can shut down the application properly.
   </para>
  </sect2>

  <sect2 id="signals.connection.multiple">
   <title>Multiple Connections</title>
   <simpara>
    With PHP-GTK you can register more than one function to be invoked when
    a signal is emitted by a widget.  This allows you to set up a whole set
    of functions to be called in response to an expected action.
   </simpara>
   <para>
    When more than one function is connected to a signal, the functions are
    called in the order in which they were registered when that signal is
    emitted.
    <example>
     <title>Signal Callback Order</title>
     <programlisting role="php">
<![CDATA[
<?php
if( !extension_loaded('gtk')) {	
    dl( 'php_gtk.' . PHP_SHLIB_SUFFIX); 
}

function first($button) 
{
    print "First function has been called\n";
}

function second($button) 
{
    print "Second function has been called\n";
}

$window = &new GtkWindow();
$window->connect_object("destroy", array("gtk", 
"main_quit"));

$button = &new GtkButton("Click Me!!");
$button->connect("clicked","first");
$button->connect("clicked","second");
$window->add($button);

$window->show_all();

gtk::main();

?>
]]>
     </programlisting>
    </example>
    In the above example we connect two functions to a button's
    <signalname>clicked</signalname> signal.  The first call to the
    <function class="GtkObject">connect</function> method connects the
    <signalname>clicked</signalname> signal to the <literal>first()</literal> 
    function, the second call connects the <signalname>clicked</signalname> 
    signal to the <literal>second()</literal> function.
   </para>
   <para>
    The output from this program would be:
    <screen>
First function has been called.
Second function has been called.
    </screen>
   </para>
  </sect2>
 </sect1>
 
 <sect1 id="signals.custom.params">
  <title>Using Custom Parameters</title>
  <sect2 id="signals.custom.data">
   <title>Passing Custom Data as a Parameter</title>
   <simpara>
    When <link linkend="signals.connection">connecting</link> signals,
    it is possible to add an extra custom parameter to the callback.  This
    is useful for passing the object you want to perform an action on, to
    your callback function.
   </simpara>
   <simpara>
    For example, when a button is pressed we might want to destroy the parent
    instance of <classname>GtkWindow</classname> that that instance of
    <classname>GtkButton</classname> has been 
    <function class="gtkcontainer">add</function>ed to.
   </simpara>
   <simpara>
    You can do this by including an optional third parameter to the 
    <function class="GtkObject">connect</function> call. This will then be
    passed to your signal handler function as the final callback parameter.
   </simpara>
   <para>
    <example>
     <title>
      Using Custom Parameters with the 
      <function class="GtkObject">connect</function> method.
     </title>
     <programlisting role="php">
<![CDATA[
<?php

function button_clicked($button, $window) 
{
    $window->destroy();
    gtk::main_quit();
}

$window = &new GtkWindow();

$button = &new GtkButton("exit");
$button->connect("clicked","button_clicked", $window);

$window->add($button);
$window->show_all();

gtk::main();

?>
]]>
     </programlisting>
    </example>
    In the above code you can see that we pass not only the
    <literal>$button</literal> variable, an instance of
    <classname>GtkButton</classname>, to the <signalname>clicked</signalname> 
    callback but also the <literal>$window</literal> variable, an instance
    of the <classname>GtkWindow</classname> class.  This allows us to call
    the <function class="GtkObject">destroy</function> method on the window.
   </para>
   <note>
    <simpara>
     You can have as many custom parameters as you want.
    </simpara>
   </note>
   <para>
    By passing the <literal>$button</literal> variable as our calling object
    parameter and the <literal>$window</literal> variable as our custom
    parameter, we could use this same callback for more than one
    <classname>GtkButton</classname> on more than one
    <classname>GtkWindow</classname>.  Note that the names given to the
    parameters within the callback are irrelevant outside the callback
    function; PHP-GTK picks up on the positions of the parameters in the
    connect* method calls and passes these to the variables listed in the
    callback declaration as an array, so that any instance of a connection
    using the same parameter structure can use that same callback.  This is
    demonstrated in the code below using a single custom parameter, but is
    equally true for more than one.
    <example>
     <title>Using the same callback for more than one window</title>
     <programlisting role="php">
<![CDATA[
<?php

function button_clicked($button, $window)
{
    $window->set_title("titled");
}

$window1 = &new GtkWindow();
$window1->connect_object("destroy", array("gtk", 
"main_quit"));
$window2 = &new GtkWindow();
$window2->connect_object("destroy", array("gtk", 
"main_quit"));

$button1 = &new GtkButton("click me");
$button2 = &new GtkButton("or me");

$button1->connect("clicked", "button_clicked", 
$window1);
$button2->connect("clicked", "button_clicked", 
$window2);

$window1->add($button1);
$window2->add($button2);

$window1->show_all();
$window2->show_all();

gtk::main();

?>
]]>
     </programlisting>
    </example>
   </para>
  </sect2>
 
  <sect2 id="signals.connect.object">
   <title>Using the connect_object* methods</title>
   <para>
    Both <function class="GtkObject">connect_object</function> and 
    <function class="GtkObject">connect_object_after</function> allow you
    to pass an object other than the calling object as the first parameter
    to your callback function. This is mainly used for calling static
    PHP-GTK functions, as in (for example) the 
    <function>gtk::main_quit</function> function:
    <example>
     <title>
      Using the <function class="GtkObject">connect_object</function> 
      method to specify a built-in function as callback.
     </title>
     <programlisting role="php">
<![CDATA[
<?php

$window = &new GtkWindow();
$window->connect_object("destroy", array("gtk", 
"main_quit"));
$window->show();

gtk::main();

?>
]]>
     </programlisting>
    </example>
    This could be called on any static function or method by using the
    <literal>gtkobject::method</literal> syntax expressed as an array.
   </para>
   <para>
    It also means you can have a single callback for multiple signals.  For
    example; you might create a window containing (within the necessary
    container widgets) a <classname>GtkMenuBar</classname>, a
    <classname>GtkToolbar</classname> and a <classname>GtkButton</classname>. 
    When <literal>Exit</literal> is chosen by the user through any of these
    widgets, a shutdown function could be invoked by passing the instance of
    <classname>GtkWindow</classname> as its first parameter, allowing the
    window to be destroyed from any of those connections.  The callback
    function and the connections in this instance would look like this:
    <example>
     <title>
      Using the <function class="GtkObject">connect_object</function> 
      method to pass another object as first parameter.
     </title>
     <programlisting role="php">
<![CDATA[
<?php

function destroy_window($window)
{
    $window->destroy();
    gtk::main_quit();
}

$exit_button->connect_object("clicked", 
"destroy_window", $window);

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    The connect_after* methods allow callbacks to be "run after"
    the default signal handler for that signal.  This can be useful
    in some situations; for example, where you want to destroy only one of
    several windows in a given circumstance.  However, connect_after* methods
    will only work when a signal has been created in the GTK source with a 
    <literal>GTK_RUN_LAST</literal> flag.  The 
    <signalname>destroy</signalname> signal and all the
    <literal>'event'</literal> signals have this flag; beyond that,
    the only way to check is to either test the signal within PHP-GTK or
    read the GTK source.
    <example> 
     <title>Using the 
      <function class="GtkObject">connect_after</function> method.
     </title>
     <programlisting role="php">
<![CDATA[
<?php

function quit_routine($window) 
{
    print("Shutting down...\n");
    gtk::main_quit();
}

$window1 = &new GtkWindow();
$window1->set_title("Quit the main loop");
$window1->connect("destroy", "quit_routine");

$window2 = &new GtkWindow();
$window2->set_title("Destroy this window");
$window2->connect_after("destroy", "quit_routine");

$window1->show();
$window2->show();

gtk::main();

?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    See also: <classname>GtkObject</classname>, 
    <function class="GtkObject">connect_after</function>
    <function class="GtkObject">connect_object</function> and 
    <function class="GtkObject">connect_object_after</function>.
   </simpara>
  </sect2>
 </sect1>

 <sect1 id="signals.events">
  <title>Signals and Events</title>
  <simpara>
   <emphasis>GTK Signals, GDK Events.</emphasis>
  </simpara>
  <simpara>
   Signals are not events, and events are not signals.  A signal is a message
   emitted by an instance of a <classname>GtkObject</classname> in response
   to some predetermined element in its environment, e.g. an action by the
   end user, or an instruction from a function or method.  Signals are always
   programmed into the code, either internally within GTK or externally by
   the PHP-GTK programmer.
  </simpara>
  <simpara>
   Events, on the other hand, are a continual stream of impulses
   communicating messages concerning environmental changes in the underlying
   windowing system.  The GTK main loop is made up of this stream of events, 
   among other things.
  </simpara>
  <note>
   <simpara>
    It is not possible to connect a callback function to a 
    <classname>GdkEvent</classname> directly.
   </simpara>
  </note>
  <simpara>
   Any widget having its own <classname>GdkWindow</classname> may capture
   events that are relevant to it.  Widgets lacking a 
   <classname>GdkWindow</classname> - those created with the 
   <literal>GTK_NO_WINDOW</literal> flag - cannot do so, unless they are
   housed within a <classname>GtkEventBox</classname> - a widget created for
   this specific purpose.  There are occasions when it is useful to be able
   to capture events; one obvious example would be the creation of an instance
   of <classname>GtkToolTips</classname> which is triggered when its subject
   widget captures the <literal>GDK_ENTER_NOTIFY</literal> event and
   destroyed when the same widget captures the
   <literal>GDK_LEAVE_NOTIFY</literal> event.
  </simpara>
  <simpara>
   Although it is not possible to use an event to trigger a callback in the
   same way as a signal, there are a series of signals derived from 
   <classname>GtkWidget</classname> collectively known as 
   <literal>'event' signals</literal>.  These are effectively ways
   of describing an event in terms of a signal, allowing callbacks to be
   indirectly triggered through a captured occurrence of most of the 
   <enumname>GdkEventTypes</enumname>. The 
   <classname>GtkTooltips</classname>  object itself uses the 
   <function class="GktObject">connect_object</function> method and the
   generic <signalname>event</signalname> signal in order to monitor its
   subject widget.
  </simpara>
  <para>
   The concept of events is not an easy one to grasp.  Please copy, paste
   and run the following script in order to see the flow of events over a
   widget in action.
   <example>
    <title>Demonstration of the flow of events across a
     <classname>GtkButton</classname>
    </title>
    <programlisting role="php">
<![CDATA[
<?php
if( !extension_loaded('gtk')) {	
    dl( 'php_gtk.' . PHP_SHLIB_SUFFIX) || die("Can't load php_gtk module!\n"); 
}

function show_event_type($button, $event, $text) 
{
    $event_type = $event->type;
    $insert = $text->get_length();
    $text->freeze();
    switch($event_type) {
      case 2:
        $text->insert_text("GDK_EXPOSE\n", $insert);
      break;
      case 3:
        $text->insert_text("GDK_MOTION_NOTIFY\n", $insert);
      break;
      case 4:
        $text->insert_text("GDK_BUTTON_PRESS\n", $insert);
      break;
      case 5:
        $text->insert_text("GDK_2BUTTON_PRESS\n", $insert);
        $button->hide();
      break;
      case 7:
        $text->insert_text("GDK_BUTTON_RELEASE\n", $insert);
      break;
      case 8:
        $text->insert_text("GDK_KEY_PRESS\n", $insert);
      break;
      case 9:
        $text->insert_text("GDK_KEY_RELEASE\n", $insert);
      break;
      case 10:
        $text->insert_text("GDK_ENTER_NOTIFY\n", $insert);
      break;
      case 11:
        $text->insert_text("GDK_LEAVE_NOTIFY\n", $insert);
      break;
      case 12:
        $text->insert_text("GDK_FOCUS_CHANGE\n", $insert); 
      break;
      case 14:
        $text->insert_text("GDK_MAP\n", $insert);
      break;
      case 15:
        $text->insert_text("GDK_UNMAP\n", $insert);
        $button->destroy();
        $text->insert_text(
"\n* GDK EVENTS AND GTK SIGNALS - background stream vs foreground 
messaging *
\n
* Most GdkEventTypes have counterpart GTK signals, known as 'event'
  signals, implemented in GtkWidget.  The types on your screen are there
  because the GtkButton was programmed to emit the generic 'event' signal
  each time it captured one of the stream of GDK events that makes up the
  GTK main loop.  In each case, the captured GdkEvent was passed as a
  callback parameter so that its enumerated type value could be determined
  within the signal handler function.  Scroll down to see the series of event
  values captured during your recent interaction with the GtkButton widget. *
\n
* Please note that the majority of GTK signals do NOT correspond to GDK
  events in this or any other way!  For example, the signal connection
                      \$button->connect('pressed', 'whatever');
  has no relationship to the GDK_BUTTON_PRESS event it generates, which
  refers to mouse-button activity and not to the GtkButton 'pressed' signal. *
\n", 0);
      break;
    }
    $text->thaw();
    return false;
}

$window = &new GtkWindow();
$window->set_position(GTK_WIN_POS_CENTER);
$window->set_default_size((gdk::screen_width()/1.5), 
(gdk::screen_height()-20));
$window->connect_object("destroy", array("gtk", 
"main_quit"));
$window->realize();

$box = &new GtkVBox(false, 5);
$window->add($box);
$scrlwin = &new GtkScrolledWindow();
$box->pack_start($scrlwin, true, true, 0);
$text = &new GtkText();
$scrlwin->add($text);

$button = &new GtkButton("Double-click here for information..");
$button->add_events(GDK_ALL_EVENTS_MASK);
$button->connect("event", "show_event_type", $text);
$box->pack_end($button, false, false, 5);

$window->show_all();

gtk::main();

?>
]]>
    </programlisting>
   </example>
  </para>
 </sect1>

</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->