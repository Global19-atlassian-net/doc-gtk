<?xml version="1.0" encoding="ISO-8859-1" ?>
<chapter id="signals">
 <title>Signale und Callbacks</title>
 <sect1 id="signals.intro"></sect1>

 <sect1 id="signals.whatare">
  <title>Was sind Signale?</title>
  <simpara>
   <emphasis>Signale sind Benachrichtigungen, die von
   <link linkend="widgets.whatare">Widgets</link> im Falle eines
    Ereignisses gesendet werden.</emphasis>
  </simpara>
  <simpara>
   Wenn man Grafische Benutzeroberflächen (<acronym>GUI</acronym>s)
   programmiert, ist es oftmals nötig, auf Aktionen des Benutzers zu
   reagieren.
   <acronym>GNOME</acronym> und <acronym>GTK+</acronym> tun dies mittels
   Signalen. Signale werden hauptsächlich verwendet um dem Programm
   mitzuteilen, dass etwas passiert ist. Dies kann das Klicken eines
   Benutzers auf einen <classname>GtkButton</classname> oder eine
   Veränderung an einer Instanz von <classname>GtkAdjustment</classname>.
  </simpara>
  <simpara>
   Ein Programm könnte, zum Beispiel, <classname>GtkAdjustment</classname>
   veranlassen, sein <signalname>changed</signalname> Signal auszusenden, 
   wenn ein Programm eine seiner Eigenschaften ändert.  Eine andere Situation
   wäre, wenn ein Benutzer auf eine Instanz von 
   <classname>GtkButton</classname> klickt und es somit veranlasst, sein 
   <signalname>clicked</signalname> Signal auszusenden.  Als Programmierer
   können Sie sogenannte 
   <link linkend="callbacks.whatare">Callbacks</link> anlegen, die auf
   diese Signale reagieren.
  </simpara>
 </sect1>

 <sect1 id="callbacks.whatare">
  <title>Was sind Callbacks?</title>
  <simpara>
   <emphasis>
    Callbacks sind Funktionen und Methoden die aufgerufen werden wenn
    <link linkend="signals.whatare">Signale</link> von
    <link linkend="widgets.whatare">Widgets</link> ausgesendet werden.
   </emphasis>
  </simpara>
  <simpara>
   Callbacks sind Funktionen und Methoden die vom Programmierer angelegt
   werden, um auf von Widgets gesendete Signale zu reagieren. Sie können die
   Funktion festlegen, die dann aufgerufen werden soll, indem Sie die
   Funktion mit dem Signal 
   <link linkend="signals.connection">verbinden</link>.
  </simpara>
 </sect1>

 <sect1 id="signals.inheritance">
  <title>Signalvererbung</title>
  <simpara>
   Signale werden von Objekten vererbt, genau wie das bei Methoden der Fall
   ist.  Ein Widget kann jedes Signal senden, dass sein Vaterobjekt definiert
   hat, und auch seine eigenen spezifischen Signale.
  </simpara>
 </sect1>

 <sect1 id="signals.connection">
  <title>Connecting Signals</title>

  <sect2 id="signals.connection.simple">
   <title>Simple Connections</title>
   <simpara>
    To react to a signal you must connect to it by specifying a callback
    function for PHP-GTK to call when that signal is emitted.
   </simpara>
   <simpara>
    Connecting a function to a signal is achieved by calling the
    <function class="GtkObject">connect</function> method of the object.
   </simpara>
   <simpara>
    The function that you register as the callback for a signal must have
    the correct prototype.  You can find what the prototype should be from
    the <link linkend="reference">reference</link> section of this manual.
   </simpara>
   <simpara>
    For example, if you wanted to connect to the
    <signalname>clicked</signalname> signal of an instance of 
    <classname>GtkButton</classname> you should define a function that
    accepts one parameter, which will be the button that was clicked.
   </simpara>
   <para>
    The code below shows how you might create a window, add a button to it,
    wait for it to be clicked and then, when it is clicked, open a new
    <classname>GtkWindow</classname> containing a message.
    <example>
     <title>Signals and Callbacks</title>
     <programlisting role="php">
<![CDATA[
<?php

function shutdown() 
{
    print("Shutting down...\n");
    gtk::main_quit();
}

function you_clicked($button) 
{
    $window = &new GtkWindow();
    $label = &new GtkLabel("You clicked the button");
    $window->add($label);
    $window->connect("destroy","shutdown");
    $window->show_all();
    return false;
}

$window = &new GtkWindow();
$window->connect("destroy", "shutdown");
$window->set_border_width(10);
    
$button = &new GtkButton("Click Me!!");
$button->connect("clicked", "you_clicked");
$window->add($button);

$window->show_all();

gtk::main();

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    The important part here is where we call
    <literal>$button-&gt;connect();</literal>
    The connect method here registers the <literal>you_clicked()</literal> 
    function as the callback that will be invoked when the 
    <signalname>clicked</signalname> signal is emitted by the 
    <classname>GtkButton</classname> widget.  We also register the 
    <literal>shutdown()</literal> function as the handler for the 
    <signalname>destroy</signalname> signal for both windows so that we
    can shut down the application properly.
   </para>
  </sect2>

  <sect2 id="signals.connection.multiple">
   <title>Multiple Connections</title>
   <simpara>
    With PHP-GTK you can register more than one function to be invoked when
    a signal is emitted by a widget.  This allows you to set up a whole set
    of functions to be called in response to an expected action.
   </simpara>
   <para>
    When more than one function is connected to a signal, the functions are
    called in the order in which they were registered when that signal is
    emitted.
    <example>
     <title>Signal Callback Order</title>
      <programlisting role="php">
<![CDATA[
<?php

function first($button) 
{
    print "First function has been called\n";
}
    
function second($button) 
{
    print "Second function has been called\n";
}

$window = &new GtkWindow();
$window->connect_object("destroy", array("gtk", 
"main_quit"));

$button = &new GtkButton("Click Me!!");
$button->connect("clicked","first");
$button->connect("clicked","second");
$window->add($button);

$window->show_all();

gtk::main();

?>
]]>
     </programlisting>
    </example>
    In the above example we connect two functions to a button's
    <signalname>clicked</signalname> signal.  The first call to the
    <function class="GtkObject">connect</function> method connects the
    <signalname>clicked</signalname> signal to the <literal>first()</literal>
    function, the second call connects the <signalname>clicked</signalname>
    signal to the <literal>second()</literal> function.
   </para>
   <para>
    The output from this program would be:
    <screen>
First function has been called.
Second function has been called.
    </screen>
   </para>
  </sect2>
 </sect1>
 
 <sect1 id="signals.custom.params">
  <title>Verwendung von eigenen Parametern</title>
  <sect2 id="signals.custom.data">
   <title>Eigene Daten als Parameter übergeben</title>
   <simpara>
    Beim <link linkend="signals.connection">verbinden</link> von Signalen
    ist es möglich, einen zusätzlichen eigenen Parameter an den Callback
    zu übergeben. Dies ist oft nützlich um das Objekt auf das man eine
    Aktion anwenden will an den Callback zu übergeben.
   </simpara>
   <simpara>
    Wenn zum Beispiel ein Button gedrückt wird, möchte man vielleicht
    die Vaterinstanz von <classname>GtkWindow</classname>, zu der diese Instanz von
    <classname>GtkButton</classname> hinzugefügt
    (ge<function class="gtkcontainer">add</function>et) wurde, zerstören.
   </simpara>
   <simpara>
    Dies kann man dann z.B. tun indem man einen optionalen dritten Parameter
    zum <function class="GtkObject">connect</function> Aufruf hinzufügt.
    Dieser Parameter wird dann zu Ihrer Callbackfunktion als letzter an den
    Callback übergebenen Parameter weitergegeben.
   </simpara>
   <para>
    <example>
     <title>
      Verwendung von eigenen Parametern mit 
      <function class="GtkObject">connect</function>
     </title>
     <programlisting role="php">
<![CDATA[
<?php

function button_clicked($button, $window) 
{
    $window->destroy();
    gtk::main_quit();
}

$window = &new GtkWindow();

$button = &new GtkButton("exit");
$button->connect("clicked","button_clicked", $window);

$window->add($button);
$window->show_all();

gtk::main();

?>
]]>
     </programlisting>
    </example>
    Im obigen Code sieht man dass nicht nur die <literal>$button</literal>
    Variable, eine Instanz von <classname>GtkButton</classname>, zum
    <signalname>clicked</signalname> Callback hinzugefügt wurde,
    sondern auch die <literal>$window</literal> Variable, eine Instanz der
    <classname>GtkWindow</classname> Klasse. Dies erlaubt den Aufruf von
    <function class="GtkObject">destroy</function> und das Schliessen
    des Fensters.
   </para>
   <note>
    <simpara>
     Sie können so viele eigene Parameter verwenden wie Sie möchten.
    </simpara>
   </note>
   <para>
    By passing the <literal>$button</literal> variable as our calling object
    parameter and the <literal>$window</literal> variable as our custom
    parameter, we could use this same callback for more than one
    <classname>GtkButton</classname> on more than one
    <classname>GtkWindow</classname>.  Note that the names given to the
    parameters within the callback are irrelevant outside the callback
    function; PHP-GTK picks up on the positions of the parameters in the
    connect* method calls and passes these to the variables listed in the
    callback declaration as an array, so that any instance of a connection
    using the same parameter structure can use that same callback.  This is
    demonstrated in the code below using a single custom parameter, but is
    equally true for more than one.
    <example>
     <title>Using the same callback for more than one window</title>
     <programlisting role="php">
<![CDATA[
<?php

function button_clicked($button, $window)
{
    $window->set_title("titled");
}

$window1 = &new GtkWindow();
$window1->connect_object("destroy", array("gtk", 
"main_quit"));
$window2 = &new GtkWindow();
$window2->connect_object("destroy", array("gtk", 
"main_quit"));

$button1 = &new GtkButton("click me");
$button2 = &new GtkButton("or me");

$button1->connect("clicked", "button_clicked", 
$window1);
$button2->connect("clicked", "button_clicked", 
$window2);

$window1->add($button1);
$window2->add($button2);

$window1->show_all();
$window2->show_all();

gtk::main();

?>
]]>
     </programlisting>
    </example>
   </para>
  </sect2>
 
  <sect2 id="signals.connect.object">
   <title>Using the connect_object* methods</title>
   <para>
    Both <function class="GtkObject">connect_object</function> and 
    <function class="GtkObject">connect_object_after</function> allow you
    to pass an object other than the calling object as the first parameter
    to your callback function. This is mainly used for calling static
    PHP-GTK functions, as in (for example) the 
    <function>gtk::main_quit</function> function:
    <example>
     <title>
      Using the <function class="GtkObject">connect_object</function> 
      method to specify a built-in function as callback.
     </title>
     <programlisting role="php">
<![CDATA[
<?php

$window = &new GtkWindow();
$window->connect_object("destroy", array("gtk", 
"main_quit"));
$window->show();

gtk::main();

?>
]]>
     </programlisting>
    </example>
    This could be called on any static function or method by using the
    <literal>gtkobject::method</literal> syntax expressed as an array.
   </para>
   <para>
    It also means you can have a single callback for multiple signals.  For
    example; you might create a window containing (within the necessary
    container widgets) a <classname>GtkMenuBar</classname>, a
    <classname>GtkToolbar</classname> and a <classname>GtkButton</classname>. 
    When <literal>Exit</literal> is chosen by the user through any of these
    widgets, a shutdown function could be invoked by passing the instance of
    <classname>GtkWindow</classname> as its first parameter, allowing the
    window to be destroyed from any of those connections.  The callback
    function and the connections in this instance would look like this:
    <example>
     <title>
      Using the <function class="GtkObject">connect_object</function> 
      method to pass another object as first parameter.
     </title>
      <programlisting role="php">
<![CDATA[
<?php

function destroy_window($window)
{
    $window->destroy();
    gtk::main_quit();
}

$exit_button->connect_object("clicked", 
"destroy_window", $window);

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    The connect_after* methods allow callbacks to be "run after"
    the default signal handler for that signal.  This can be useful
    in some situations; for example, where you want to destroy only one of
    several windows in a given circumstance.  However, connect_after* methods
    will only work when a signal has been created in the GTK source with a 
    <literal>GTK_RUN_LAST</literal> flag.  The 
    <signalname>destroy</signalname> signal and all the
    <literal>'event'</literal> signals have this flag; beyond that,
    the only way to check is to either test the signal within PHP-GTK or
    read the GTK source.
    <example> 
     <title>Using the 
      <function class="GtkObject">connect_after</function> method.
     </title>
     <programlisting role="php">
<![CDATA[
<?php

function quit_routine($window) 
{
    print("Shutting down...\n");
    gtk::main_quit();
}

$window1 = &new GtkWindow();
$window1->set_title("Quit the main loop");
$window1->connect("destroy", "quit_routine");

$window2 = &new GtkWindow();
$window2->set_title("Destroy this window");
$window2->connect_after("destroy", "quit_routine");

$window1->show();
$window2->show();

gtk::main();

?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    See also: <classname>GtkObject</classname>, 
    <function class="GtkObject">connect_after</function>
    <function class="GtkObject">connect_object</function> and 
    <function class="GtkObject">connect_object_after</function>.
   </simpara>
  </sect2>
 </sect1>

 <sect1 id="signals.events">
  <title>Signals and Events</title>
  <simpara>
   <emphasis>GTK Signals, GDK Events.</emphasis>
  </simpara>
  <simpara>
   Signals are not events, and events are not signals.  A signal is a message
   emitted by an instance of a <classname>GtkObject</classname> in response
   to some predetermined element in its environment, e.g. an action by the
   end user, or an instruction from a function or method.  Signals are always
   programmed into the code, either internally within GTK or externally by
   the PHP-GTK programmer.
  </simpara>
  <simpara>
   Events, on the other hand, are a continual stream of impulses
   communicating messages concerning environmental changes in the underlying
   windowing system.  The GTK main loop is made up of this stream of events, 
   among other things.
  </simpara>
  <note>
   <simpara>
    It is not possible to connect a callback function to a 
    <classname>GdkEvent</classname> directly.
   </simpara>
  </note>
  <simpara>
   Any widget having its own <classname>GdkWindow</classname> may capture
   events that are relevant to it.  Widgets lacking a 
   <classname>GdkWindow</classname> - those created with the 
   <literal>GTK_NO_WINDOW</literal> flag - cannot do so, unless they are
   housed within a <classname>GtkEventBox</classname> - a widget created for
   this specific purpose.  There are occasions when it is useful to be able
   to capture events; one obvious example would be the creation of an instance
   of <classname>GtkToolTips</classname> which is triggered when its subject
   widget captures the <literal>GDK_ENTER_NOTIFY</literal> event and
   destroyed when the same widget captures the
   <literal>GDK_LEAVE_NOTIFY</literal> event.
  </simpara>
  <simpara>
   Although it is not possible to use an event to trigger a callback in the
   same way as a signal, there are a series of signals derived from 
   <classname>GtkWidget</classname> collectively known as 
   <literal>'event' signals</literal>.  These are effectively ways
   of describing an event in terms of a signal, allowing callbacks to be
   indirectly triggered through a captured occurrence of most of the 
   <enumname>GdkEventTypes</enumname>. The 
   <classname>GtkTooltips</classname>  object itself uses the 
   <function class="GktObject">connect_object</function> method and the
   generic <signalname>event</signalname> signal in order to monitor its
   subject widget.
  </simpara>
  <para>
   The concept of events is not an easy one to grasp.  Please copy, paste
   and run the following script in order to see the flow of events over a
   widget in action.
   <example>
    <title>Demonstration of the flow of events across a
     <classname>GtkButton</classname>
    </title>
    <programlisting role="php">
<![CDATA[
<?php

dl("php_gtk." . (strstr(PHP_OS, "WIN") ? "dll" : 
"so")) ||
die("Can't load php_gtk module!\n");

function show_event_type($button, $event, $text) 
{
    $event_type = $event->type;
    $insert = $text->get_length();
    $text->freeze();
    switch($event_type) {
      case 2:
        $text->insert_text("GDK_EXPOSE\n", $insert);
      break;
      case 3:
        $text->insert_text("GDK_MOTION_NOTIFY\n", $insert);
      break;
      case 4:
        $text->insert_text("GDK_BUTTON_PRESS\n", $insert);
      break;
      case 5:
        $text->insert_text("GDK_2BUTTON_PRESS\n", $insert);
        $button->hide();
      break;
      case 7:
        $text->insert_text("GDK_BUTTON_RELEASE\n", $insert);
      break;
      case 8:
        $text->insert_text("GDK_KEY_PRESS\n", $insert);
      break;
      case 9:
        $text->insert_text("GDK_KEY_RELEASE\n", $insert);
      break;
      case 10:
        $text->insert_text("GDK_ENTER_NOTIFY\n", $insert);
      break;
      case 11:
        $text->insert_text("GDK_LEAVE_NOTIFY\n", $insert);
      break;
      case 12:
        $text->insert_text("GDK_FOCUS_CHANGE\n", $insert); 
      break;
      case 14:
        $text->insert_text("GDK_MAP\n", $insert);
      break;
      case 15:
        $text->insert_text("GDK_UNMAP\n", $insert);
        $button->destroy();
        $text->insert_text(
"\n* GDK EVENTS AND GTK SIGNALS - background stream vs foreground 
messaging *
\n
* Most GdkEventTypes have counterpart GTK signals, known as 'event'
  signals, implemented in GtkWidget.  The types on your screen are there
  because the GtkButton was programmed to emit the generic 'event' signal
  each time it captured one of the stream of GDK events that makes up the
  GTK main loop.  In each case, the captured GdkEvent was passed as a
  callback parameter so that its enumerated type value could be determined
  within the signal handler function.  Scroll down to see the series of event
  values captured during your recent interaction with the GtkButton widget. *
\n
* Please note that the majority of GTK signals do NOT correspond to GDK
  events in this or any other way!  For example, the signal connection
                      \$button->connect('pressed', 'whatever');
  has no relationship to the GDK_BUTTON_PRESS event it generates, which
  refers to mouse-button activity and not to the GtkButton 'pressed' signal. *
\n", 0);
      break;
    }
    $text->thaw();
    return false;
}

$window = &new GtkWindow();
$window->set_position(GTK_WIN_POS_CENTER);
$window->set_default_size((gdk::screen_width()/1.5), 
(gdk::screen_height()-20));
$window->connect_object("destroy", array("gtk", 
"main_quit"));
$window->realize();

$box = &new GtkVBox(false, 5);
$window->add($box);
$scrlwin = &new GtkScrolledWindow();
$box->pack_start($scrlwin, true, true, 0);
$text = &new GtkText();
$scrlwin->add($text);

$button = &new GtkButton("Double-click here for information..");
$button->add_events(GDK_ALL_EVENTS_MASK);
$button->connect("event", "show_event_type", $text);
$box->pack_end($button, false, false, 5);

$window->show_all();

gtk::main();

?>
]]>
    </programlisting>
   </example>
  </para>
 </sect1>

</chapter>
