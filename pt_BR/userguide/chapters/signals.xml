<?xml version="1.0" encoding="ISO-8859-1" ?>
<chapter id="signals">
 <title>Signals e Callbacks</title>
 <sect1 id="signals.intro"></sect1>

 <sect1 id="signals.whatare">
  <title>O que são Signals (Sinais)?</title>
  <simpara>
   <emphasis>Signals são notificações (mensagens) emitidas por
   <link linkend="widgets.whatare">widgets</link>.</emphasis>
  </simpara>
  <simpara>
   Quando se programa Interfaces Gráficas (<acronym>GUI</acronym>), 
   é geralmente necessário responder a ações realizadas pelo usuário ou
   iniciadas dentro do próprio programa. <acronym>GNOME</acronym> 
   e <acronym>GTK+</acronym> faz isso via o uso de signals.  Signals são
   usados para que o programa saiba o que aconteceu. Isto pode ser, por
   exemplo, um usuário clicando em um <classname>GtkButton</classname>,
   ou uma mudança sendo feito em um <classname>GtkAdjustment</classname>.
  </simpara>
  <simpara>
   Um programa pode por exemplo, fazer com que um 
   <classname>GtkAdjustment</classname> emita seu sinal de 
   <signalname>value-changed</signalname> quando um widget muda um de seus
   valores de ajuste.  Este sinal em particular é usado tanto internamente
   como externamente no <classname>GtkAdjustment</classname>, Então não é
   sempre necessário escrever o sinal no código-fonte, para dizer a uma 
   <classname>GtkProgressBar</classname> usá-lo.  Uma situação mais comum
   pode acontecer quando um usuário clica em uma instância de um 
   <classname>GtkButton</classname>, fazendo com que o widget button emita
   o sinal de <signalname>clicked</signalname>.  Como programador, você pode
   registrar uma <link linkend="callbacks.whatare">callbacks</link> para
   reagir a qualquer sinal emitido por um widget.
  </simpara>
 </sect1>

 <sect1 id="callbacks.whatare">
  <title>O que são Callbacks?</title>
  <simpara>
   <emphasis>
    Callbacks são funções que são invocadas quando
    <link linkend="signals.whatare">signals</link> (sinais) são emitidos
    por <link linkend="widgets.whatare">widgets</link>.
   </emphasis>
  </simpara>
  <simpara>
   Callbacks são funções que são registradas pelo programador para reagir a
   sinais emitidos por widgets.  Você especifica qual função será executada
   quando <link linkend="signals.connection">conecta</link> a função
   ao sinal.
  </simpara>
  <simpara>
   O CallBack também é conhecido como função que manipula o sinal.  Pode ser
   tanto um <literal>manipulador (handler) default</literal> do widget ou um 
   <literal>manipulador (handler) definido pelo usuário</literal>, ou seja,
   uma função escrita por um programador.
  </simpara>
 </sect1>

 <sect1 id="signals.inheritance">
  <title>Herança de Signal (sinais)</title>
  <simpara>
   Sinais são herdados por objetos como são os métodos.  Um widget pode
   emitir qualquer sinal que seu objeto pai tem definido, tão bem como seu
   próprios sinais.
  </simpara>
  <simpara>
   Quando os sinais não são relevantes para o widget mas são herdados por
   ele, não haverá mensagens de erro quando o signal for chamado, mas
   igualmente não haverá significado para o widget emitir um sinal em
   particular.
  </simpara>
 </sect1>

 <sect1 id="signals.connection">
  <title>Conectando sinais</title>

  <sect2 id="signals.connection.simple">
   <title>Conexões Simples</title>
   <simpara>
    Para que um sinal reaja, você deve conectar ele a uma função callback
    para que o PHP-GTK chame quando o sinal for emitido.
   </simpara>
   <simpara>
    Conectar uma função a um sinal é alcançado chamando o método
    <function class="GtkObject">connect</function>.
   </simpara>
   <simpara>
    A função que você registra como callback para um sinal deve ter um
    protótipo correto. Você pode encontrar qual protótipo deveria ser da
    seção <link linkend="reference">reference</link> deste manual.
   </simpara>
   <simpara>
    Por exemplo, se você quisesse conectar ao sinal
    <signalname>clicked</signalname> de uma instancia de um
    <classname>GtkButton</classname> você deveria definir uma função que
    aceitasse um parâmetro, que será o botão quando ele for clicado.
   </simpara>
    <para>
     O código abaixo mostra como você pode criar uma janela, adicionar um botão,
     esperar por ser clicado e então, quando for clicado, abrir uma nova
     <classname>GtkWindow</classname> contendo uma mensagem.
     <example>
      <title>Signals and Callbacks</title>
      <programlisting role="php">
<![CDATA[
<?php

function shutdown() 
{
    print(&quot;Caindo fora...\n&quot;);
    gtk::main_quit();
}

function you_clicked($button) 
{
    $window = &amp;new GtkWindow();
    $label = &amp;new GtkLabel(&quot;Você clicou no botão);
    $window-&gt;add($label);
    $window-&gt;connect(&quot;destroy&quot;,&quot;shutdown&quot;);
    $window-&gt;show_all();
    return false;
}

$window = &amp;new GtkWindow();
$window-&gt;connect(&quot;destroy&quot;, &quot;shutdown&quot;);
$window-&gt;set_border_width(10);

$button = &amp;new GtkButton(&quot;Click Me!!&quot;);
$button-&gt;connect(&quot;clicked&quot;, &quot;you_clicked&quot;);
$window-&gt;add($button);

$window-&gt;show_all();

gtk::main();

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    A parte importante aqui é onde chamamos
    <literal>$button-&gt;connect();</literal>
    O método connect aqui registra a função <literal>you_clicked()</literal> 
    como callback que será invocada quando o sinal de
    <signalname>clicked</signalname> é emitido pelo widget
    <classname>GtkButton</classname>.  Nós também podemos registrar a função
    <literal>shutdown()</literal> como handler (manipulador) para o sinal de
    <signalname>destroy</signalname> para ambas janelas então cairemos fora
    da aplicação.
   </para>
  </sect2>

  <sect2 id="signals.connection.multiple">
   <title>Múltiplas Conexões</title>
   <simpara>
    Com o PHP-GTK você pode registrar mais do que uma função para ser
    invocada quando um sinal é emitido por um widget. Isto permite que
    você registre um conjunto de funções para serem chamadas em resposta
    a uma ação esperada.
   </simpara>
   <para>
    Quando mais do que uma função é conectada a um sinal, as funções são
    chamadas em ordem na qual elas foram registradas quando o sinal é
    emitido.
    <example>
     <title>Ordem de Signal Callback</title>
   <programlisting role="php">
<![CDATA[
<?php

function first($button) 
{
    print &quot;Primeira função foi chamada\n&quot;;
}

function second($button) 
{
    print &quot;Segunda função foi chamada\n&quot;;
}

$window = &amp;new GtkWindow();
$window-&gt;connect_object(&quot;destroy&quot;, array(&quot;gtk&quot;, 
&quot;main_quit&quot;));

$button = &amp;new GtkButton(&quot;Click Me!!&quot;);
$button-&gt;connect(&quot;clicked&quot;,&quot;first&quot;);
$button-&gt;connect(&quot;clicked&quot;,&quot;second&quot;);
$window-&gt;add($button);

$window-&gt;show_all();

gtk::main();

?>
]]>
     </programlisting>
    </example>
    No exemplo acima, nós conectamos duas funções em um sinal
    de <signalname>clicked</signalname>. A primeira chamada ao método
    <function class="GtkObject">connect</function> conecta o sinal de 
    <signalname>clicked</signalname> a função <literal>first()</literal> 
    e a segunda chamada conecta o sinal de <signalname>clicked</signalname> 
    a função<literal>second()</literal>.
   </para>
   <para>
    O output deste programa seria:
    <screen>
Primeira função foi chamada.
Segunda função foi chamada.
    </screen>
   </para>
  </sect2>
 </sect1>
 
 <sect1 id="signals.custom.params">
  <title>Usando parâmetros Personalizados</title>
  <sect2 id="signals.custom.data">
   <title>Passando Dados Personalizados como parâmetro</title>
   <simpara>
    Quando <link linkend="signals.connection">conectamos</link> sinais, 
    é possível adicionar parâmetros extras para a função callback. Isso
    é útil para passar o objeto sobre o qual você quer realizar uma ação, 
    para a função callback.
   </simpara>
   <simpara>
    Por exemplo, quando um botão é pressionado nós podemos querer destruír
    o pai dele <classname>GtkWindow</classname> que é a instância a qual
    o <classname>GtkButton</classname> foi 
    <function class="gtkcontainer">adicionado</function>.
   </simpara>
   <simpara>
    Voê pode fazer isto incluindo um terceiro parânetro opcional
    à chamada <function class="GtkObject">connect</function>.  Isso será
    passado para a função manipuladora do sinal como o parâmetro final.
   </simpara>
   <para>
    <example>
     <title>
      Usando parâmetros Personalizados com o método 
      <function class="GtkObject">connect</function>.
     </title>
     <programlisting role="php">
<![CDATA[
<?php

function button_clicked($button, $window) 
{
    $window-&gt;destroy();
    gtk::main_quit();
}

$window = &amp;new GtkWindow();

$button = &amp;new GtkButton(&quot;exit&quot;);
$button-&gt;connect(&quot;clicked&quot;,&quot;button_clicked&quot;, $window);

$window-&gt;add($button);
$window-&gt;show_all();

gtk::main();

?>
]]>
     </programlisting>
    </example>
    No código acima você pode ver que nós passamos não apenas a variável 
    <literal>$button</literal>, uma instância de 
    <classname>GtkButton</classname>, ao sinal 
    <signalname>clicked</signalname> como também a variável 
    <literal>$window</literal>, uma instância da classe 
    <classname>GtkWindow</classname>. Isso permite à nós chamarmos a função 
    <function class="GtkObject">destroy</function> da janela.
   </para>
   <note>
    <simpara>
     Você pode ter muitos parâmetros personalizados como você quizer.
    </simpara>
   </note>
   <para>
    Passando a variável <literal>$button</literal> como parâmetro da
    chamada e a variável <literal>$window</literal> como parâmetro
    personalizável nós poderíamos usar a mesma callback para mais que um 
    <classname>GtkButton</classname> em mais do que uma 
    <classname>GtkWindow</classname>.  Note que os nomes dados aos
    parâmetros dentro da callbark são irrelevantes fora da função callback; 
    PHP-GTK usa a posição dos parâmetros no método connect e passa isso
    para as variáveis listadas na callback como em um array, então qualquer
    instância de uma conexão que usa a mesma estrutura de parâmetros pode
    usar a mesma callback.  Isso é demonstrado no código abaixo usando um
    parâmetro personalizado, mas isso funciona da mesma forma para mais do
    que um.
    <example>
     <title>Usando a mesma callback para mais do que uma window</title>
     <programlisting role="php">
<![CDATA[
<?php

function button_clicked($button, $window)
{
    $window->set_title(&quot;titled&quot;);
}

$window1 = &amp;new GtkWindow();
$window1-&gt;connect_object(&quot;destroy&quot;, array(&quot;gtk&quot;, 
&quot;main_quit&quot;));
$window2 = &amp;new GtkWindow();
$window2-&gt;connect_object(&quot;destroy&quot;, array(&quot;gtk&quot;, 
&quot;main_quit&quot;));

$button1 = &amp;new GtkButton(&quot;click me&quot;);
$button2 = &amp;new GtkButton(&quot;or me&quot;);

$button1-&gt;connect(&quot;clicked&quot;, &quot;button_clicked&quot;, 
$window1);
$button2-&gt;connect(&quot;clicked&quot;, &quot;button_clicked&quot;, 
$window2);

$window1-&gt;add($button1);
$window2-&gt;add($button2);

$window1-&gt;show_all();
$window2-&gt;show_all();

gtk::main();

?>
]]>
     </programlisting>
    </example>
   </para>
  </sect2>
 
  <sect2 id="signals.connect.object">
   <title>Usando métodos connect_object*</title>
   <para>
    Ambas <function class="GtkObject">connect_object</function> e
    <function class="GtkObject">connect_object_after</function> permitem
    a voê passar um outro objeto como primeiro parâmetro da sua função
    callback.  Isso pode ser usado principalmente para chamadas de funções
    PHP-GTK embutidas, como no exemplo da função 
    <literal>gtk::main_quit()</literal>
    <example>
     <title>
      Usando o método 
      <function class="GtkObject">connect_object</function> para
      especificar uma função embutida como callback.
     </title>
     <programlisting role="php">
<![CDATA[
<?php

$window = &amp;new GtkWindow();
$window-&gt;connect_object(&quot;destroy&quot;, array(&quot;gtk&quot;, 
&quot;main_quit&quot;));
$window-&gt;show();

gtk::main();

?>
]]>
     </programlisting>
    </example>
    Também podemos chamar funções estáticas ou métodos usando a sintaxe 
    <literal>gtkobject::method</literal> expressada como no array.
   </para>
   <para>
    Isso significa que você pode ter uma callback simples para múltiplos
    sinais.  Por exemplo; você pode criar uma janela contendo (dentro dos
    necessários widgets container) um <classname>GtkMenuBar</classname>, um 
    <classname>GtkToolbar</classname> e um<classname>GtkButton</classname>. 
    Quando <literal>Exit</literal> é escolhido pelo usuário através de
    qualquer destes widgets, uma função shutdown poderia ser invocada
    passando uma instância de <classname>GtkWindow</classname> como
    primeiro parâmetro, permitindo a janela ser destruida de qualquer uma
    destas conexões.  A função callback e as conexões nesta instância seriam
    mais ou menos assim:
    <example>
     <title>
      Usando o método 
      <function class="GtkObject">connect_object</function> para passar
      outro objeto como primeiro parâmetro.
     </title>
     <programlisting role="php">
<![CDATA[
<?php

function destroy_window($window)
{
    $window-&gt;destroy();
    gtk::main_quit();
}

$exit_button-&gt;connect_object(&quot;clicked&quot;, 
&quot;destroy_window&quot;, $window);

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    O método connect_after* permite callbacks serem 
    &quot;rodadas depois&quot; do manipulador padrão para o sinal.  Isto pode
    ser útil em algumas situações; por exemplo, você quer destruir apenas uma
    de diversas janelas em um certo momento. De qualquer forma, o método
    connect_after* irá funcionar apenas quando o sinal estiver sendo criado
    no código GTK source com uma flag
    <literal>GTK_RUN_LAST</literal>.  O sinal 
    <signalname>destroy</signalname> e o sinal 
    <literal>'event'</literal> possuem esta flag; além do que, o único modo
    de verificar é testando o sinal dentro do PHP-GTK ou lendo o código do
    GTK.
    <example> 
     <title>Usando o método
      <function class="GtkObject">connect_after</function>.
     </title>
     <programlisting role="php">
<![CDATA[
<?php

function quit_routine($window) 
{
    print(&quot;Caindo fora...\n&quot;);
    gtk::main_quit();
}

$window1 = &amp;new GtkWindow();
$window1->set_title(&quot;Saindo do loop principal&quot;);
$window1-&gt;connect(&quot;destroy&quot;, &quot;quit_routine&quot;);

$window2 = &amp;new GtkWindow();
$window2->set_title(&quot;Destroi esta janela&quot;);
$window2-&gt;connect_after(&quot;destroy&quot;, &quot;quit_routine&quot;);

$window1-&gt;show();
$window2-&gt;show();

gtk::main();

?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Veja também: <classname>GtkObject</classname>, 
    <function class="GtkObject">connect_after</function>
    <function class="GtkObject">connect_object</function> and 
    <function class="GtkObject">connect_object_after</function>.
   </simpara>
  </sect2>
 </sect1>

 <sect1 id="signals.events">
  <title>Sinais e Eventos</title>
  <simpara>
   <emphasis>Sinais GTK, Eventos GDK.</emphasis>
  </simpara>
  <simpara>
   Sinais não são eventos, e eventos não são sinais. Um sinal é uma mensagem
   emitida por uma instancia de um <classname>GtkObject</classname> em
   resposta a algum elemento predeterminado ao ambiente, isto é, uma ação
   dada pelo usuário final, ou uma instrução de uma função ou método. Sinais
   são sempre programados no código, tanto internamente dentro do GTK ou
   externamente pelo programador PHP-GTK.
  </simpara>
  <simpara>
   Eventos, de outra forma, é um fluxo contínuo de impulsos comunicando
   mensagens relativas a mudanças no ambiente subordinadas ao sistema de
   janelas.  O loop principal do GTK é feito com fluxo de eventos.
  </simpara>
  <note>
   <simpara>
    Não é possível conectar uma função callback a um evento 
    <classname>GdkEvent</classname> diretamente.
   </simpara>
  </note>
  <simpara>
   Um widget que tem sua própria <classname>GdkWindow</classname> pode
   capturar eventos que são relevantes.  Widgets necessitam de uma 
   <classname>GdkWindow</classname> - aqueles criados com a flag 
   <literal>GTK_NO_WINDOW</literal> não podem fazer isso, a menos que eles
   sejam colocados dentro de um <classname>GtkEventBox</classname> - um
   widget criado para propósitos especiais. Há ocasiões nas quais é útil
   poder capturar eventos; um exemplo óbvio seria a criação de uma instância
   de um <classname>GtkToolTips</classname> que é disparado quando um assunto
   é capturado pelo evento <literal>GDK_ENTER_NOTIFY</literal> e destruído
   quando o mesmo widget captura o evento 
   <literal>GDK_LEAVE_NOTIFY</literal> event.
  </simpara>
  <simpara>
   Embora não seja possível usar um evento para dispara uma callback da
   mesma forma como um sinal, há uma série de sinais derivados de 
   <classname>GtkWidget</classname> conhecidos como sinais 
   <literal>'event'</literal>.  Estes são modos efetivos de descrever um
   evento nos moldes de um sinal, permitindo callbacks serem indiretamente
   disparadas através da caputra da ocorrência da maioria dos 
   <enumname>GdkEventTypes</enumname>.  O objeto 
   <classname>GtkTooltips</classname> por sí próprio usa o método 
   <function class="GktObject">connect_object</function> e o sinal
   genérico <signalname>event</signalname> para monitorar seus widgets de
   assunto.
  </simpara>
  <para>
   O conceito de eventos não é facil de compreender.  Copie, cole e rode
   o script seguinte para ver o fluxo de eventos sobre o widget em ação.
   <example>
    <title>Demonstração do fluxo de eventos de um 
     <classname>GtkButton</classname>
    </title>
    <programlisting role="php">
<![CDATA[
<?php

dl(&quot;php_gtk.&quot; . (strstr(PHP_OS, &quot;WIN&quot;) ? &quot;dll&quot; : 
&quot;so&quot;)) ||
die(&quot;Can't load php_gtk module!\n&quot;);

function show_event_type($button, $event, $text) 
{
    $event_type = $event-&gt;type;
    $insert = $text->get_length();
    $text-&gt;freeze();
    switch($event_type) {
      case 2:
        $text-&gt;insert_text(&quot;GDK_EXPOSE\n&quot;, $insert);
      break;
      case 3:
        $text-&gt;insert_text(&quot;GDK_MOTION_NOTIFY\n&quot;, $insert);
      break;
      case 4:
        $text-&gt;insert_text(&quot;GDK_BUTTON_PRESS\n&quot;, $insert);
      break;
      case 5:
        $text-&gt;insert_text(&quot;GDK_2BUTTON_PRESS\n&quot;, $insert);
        $button-&gt;hide();
      break;
      case 7:
        $text-&gt;insert_text(&quot;GDK_BUTTON_RELEASE\n&quot;, $insert);
      break;
      case 8:
        $text-&gt;insert_text(&quot;GDK_KEY_PRESS\n&quot;, $insert);
      break;
      case 9:
        $text-&gt;insert_text(&quot;GDK_KEY_RELEASE\n&quot;, $insert);
      break;
      case 10:
        $text-&gt;insert_text(&quot;GDK_ENTER_NOTIFY\n&quot;, $insert);
      break;
      case 11:
        $text-&gt;insert_text(&quot;GDK_LEAVE_NOTIFY\n&quot;, $insert);
      break;
      case 12:
        $text-&gt;insert_text(&quot;GDK_FOCUS_CHANGE\n&quot;, $insert); 
      break;
      case 14:
        $text-&gt;insert_text(&quot;GDK_MAP\n&quot;, $insert);
      break;
      case 15:
        $text-&gt;insert_text(&quot;GDK_UNMAP\n&quot;, $insert);
        $button-&gt;destroy();
        $text->insert_text(
"\n* GDK EVENTS AND GTK SIGNALS - background stream vs foreground messaging *
\n
* A maioria dos GdkEventTypes tem como contrapartida sinais GTK, conhecidos como sinais
'event' implementados no GtkWidget.  As mensagens na sua tela estão lá
  por que o GtkButton estava programado para emitir um sinal genérico 'event'
  cada vez que é capturado um dos fluxos de eventos GDK que que integram
  o loop principal. Em cada caso, o GdkEvent capturado foi passado como um parâmetro
  callback, cujo tipo é enumerado como valor para poder ser determinado
  dentro da função manipuladora de sinal. Role para baixo para ver
  a série de eventos capturados durante sua interação com o widget GtkButton. *
\n
* Note que a maioria dos sinais GTK não correspondem a eventos do GDK
  de jeito nenhum ! Por exemplo, o sinal de conexão
                      \$button->connect('pressed', 'whatever');
  não tem nenhuma relação com o evento GDK_BUTTON_PRESS gerado, que
  refere-se a ativide mouse-button e não ao sinal 'pressed' do GtkButton. *
\n", 0);
      break;
    }
    $text-&gt;thaw();
    return false;
}

$window = &amp;new GtkWindow();
$window-&gt;set_position(GTK_WIN_POS_CENTER);
$window-&gt;set_default_size((gdk::screen_width()/1.5), 
(gdk::screen_height()-20));
$window-&gt;connect_object(&quot;destroy&quot;, array(&quot;gtk&quot;, 
&quot;main_quit&quot;));
$window-&gt;realize();

$box = &amp;new GtkVBox(false, 5);
$window-&gt;add($box);
$scrlwin = &amp;new GtkScrolledWindow();
$box-&gt;pack_start($scrlwin, true, true, 0);
$text = &amp;new GtkText();
$scrlwin-&gt;add($text);

$button = &amp;new GtkButton(&quot;Double-click here for information..&quot;);
$button-&gt;add_events(GDK_ALL_EVENTS_MASK);
$button-&gt;connect(&quot;event&quot;, &quot;show_event_type&quot;, $text);
$box-&gt;pack_end($button, false, false, 5);

$window-&gt;show_all();

gtk::main();

?>
]]>
    </programlisting>
   </example>
  </para>
 </sect1>

</chapter> 
