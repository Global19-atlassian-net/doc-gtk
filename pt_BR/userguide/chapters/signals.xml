<?xml version="1.0" encoding="ISO-8859-1" ?>
<!-- do not remove the comments until you reached a good translation for that 
if you are not translation do not remove the comment too, wait for a translator to remove them -->
<chapter id="signals">
 <title>Sinais e Callbacks</title>
 <sect1 id="signals.intro"></sect1>

 <sect1 id="signals.whatare">
  <title>O que são Signals?</title>
  <simpara>
   <emphasis>Sinais são notificações emitidas pelos 
   <link linkend="widgets.whatare">widgets</link>.</emphasis>
  </simpara>
  <simpara>
   Quando programando Graphical User Interfaces (<acronym>GUI</acronym>), 
   é freqüentemente necessário responder às ações realizadas pelo usuário 
   ou iniciadas pelo programa. <acronym>GNOME</acronym> e <acronym>GTK+</acronym> 
   fazem isto através do uso de sinais. Sinais são usados para informar ao 
   programa que alguma coisa aconteceu. Um sinal pode ser, por exemplo, 
   um usuário clicando em um <classname>GtkButton</classname>, ou uma alteração 
   sendo feito nos valores de <classname>GtkAdjustment</classname>.
  </simpara>
  <simpara>
   Um programa pode, por exemplo, fazer com que a clase <classname>GtkAdjustment</classname> 
   emita seu sinal <signalname>value-changed</signalname> quando um dos wigets alterar 
   um de seus valores. Este sinal em particular é usado tanto internamente quanto externamente 
   na classe <classname>GtkAdjustment</classname>, para que não seja sempre necessário 
   escrever este sinal em seu código, digamos, para que a classe <classname>GtkProgressBar</classname> 
   poder usá-lo. Uma situação bem óbvia pode ocorrer quando um usuário clica em uma instância da classe 
   <classname>GtkButton</classname>, causando a emição do sinal <signalname>clicked</signalname> pelo 
   botão. Como programdor, você pode configurar uma <link linkend="callbacks.whatare">callbacks</link> 
   para reagir à qualquer sinal emitido por um widget.
  </simpara>
 </sect1>

 <sect1 id="callbacks.whatare">
  <title>O que são Callbacks?</title>
  <simpara>
   <emphasis>
    Callbacks são funções que são invocadas quando 
	<link linkend="signals.whatare">sinais</link> são emitidos 
	por um <link linkend="widgets.whatare">widgets</link>.
   </emphasis>
  </simpara>
  <simpara>
   Callbacks são funções que são pré-definidas pelo programador para reagir 
   à sinais emitidos por widgets. Você especifica a função que deve ser chamada 
   <link linkend="signals.connection">conectando-a</link> ao sinal.
  </simpara>
  <simpara>
   Uma callback é também conhecida como um método do sinal da função. 
   Ela pode ser o <literal>evento padrão</literal> dos widgets ou um 
   <literal>evento definido pelo usuário</literal>, isto é, uma função 
   escrita pelo programador.
   <!-- difícil de traduzir: 
      The callback is also known as the signal handler function.  This can be
   either the widget's <literal>default handler</literal> or a 
   <literal>user-defined handler</literal>, that is, a function written by
   the programmer. -->
  </simpara>
 </sect1>

 <sect1 id="signals.inheritance">
  <title>Herança dos sinais</title>
  <simpara>
   O sinais são herdados dos objetos, bem como seus métodos também. Um widget 
   pode emitir qualquer um dos sinais que seu objeto (anterior) tenha definido, 
   bem como seus próprios sinais específicos.
   <!-- difícil de traduir; 
   Signals are inherited by objects, just as methods are.  A widget can
   emit any signals that its ancestor objects have defined, as well as its
   own specific signals. -->
  </simpara>
  <simpara>
   Nos casos onde o sinal não é relevante para o widget mas é herdado por ele, 
   não será emitida nenhuma mensagem de erro quando o sinal é chamado - mas 
   igualmente, não haverá nenhuma necessidade do widget emitir este sinal em 
   particular.
  </simpara>
 </sect1>

 <sect1 id="signals.connection">
  <title>Conectando Sinais</title>

  <sect2 id="signals.connection.simple">
   <title>Conexões Simples</title>
   <simpara>
    Para reagir à um sinal você deve conectá-lo especificando a função de 
	callback que o PHP-GTK terá de chamar quando este sinal for emitido.
   </simpara>
   <simpara>
    Conectar uma função ao sinal é feito chamando-se o método
	<function class="GtkObject">connect</function> do objeto.
   </simpara>
   <simpara>
    A função que você registra como sendo callback para o sinal deve ter o 
	protótipo (prototype) correto. Para saber qual prototype você de usar 
	veja ele na seção de <link linkend="reference">reference</link> do manual.
   </simpara>
   <simpara>
    Por exemplo, se você quiser conectar o sinal <signalname>clicked</signalname> 
	você deve definir uma função que aceita um parâmetro, que será o botão que foi 
	clicado.
	<!-- ficou bom?
    For example, if you wanted to connect to the
    <signalname>clicked</signalname> signal of an instance of 
    <classname>GtkButton</classname> you should define a function that
    accepts one parameter, which will be the button that was clicked.
	-->
   </simpara>
   <para>
    O código abaixo mostra como você deve criar uma janela, adicionar um botão 
	à ela, esperar que ele seja clicado, e então, quando o botão for clicado, 
	abrir uma <classname>GtkWindow</classname> contendo uma mensagem.
    <example>
     <title>Sinais e Callbacks</title>
     <programlisting role="php">
<![CDATA[
<?php
dl('php_gtk.' . (strstr(PHP_OS, 'WIN') ? 'dll' : 'so')) ||
die("Não foi possível carregar o módulo!\n");
function desligar() 
{
    print("Desligando...\n");
    gtk::main_quit();
}

function voce_clicou($botao) 
{
    $janela = &new GtkWindow();
    $rotulo = &new GtkLabel("Você clicou no botão");
    $janela->add($rotulo);
    $janela->connect("destroy","desligar");
    $janela->show_all();
    return false;
}

$janela = &new GtkWindow();
$janela->connect("destroy", "desligar");
$janela->set_border_width(10);

$botao = &new GtkButton("Clique Me!!");
$botao->connect("clicked", "voce_clicou");
$janela->add($botao);

$janela->show_all();

gtk::main();

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    A parte importante aqui é onde nós chamamos 
	<literal>$botao-&gt;connect();</literal>. 
	O método "connect" aqui é registrado à função de callback 
	<literal>voce_clicou()</literal> que irá ser invocada quando o 
	sinal <signalname>clicked</signalname> é emitido pelo widget 
	<classname>GtkButton</classname>. Nós também registramos a função 
	<literal>desligar()</literal> como sendo um evento para o sinal 
    <signalname>destroy</signalname> para ambas as janelas para que assim 
	nós possamos finalizar o programa corretamente.
   </para>
  </sect2>

  <sect2 id="signals.connection.multiple">
   <title>Múltpiplas Conexões</title>
   <simpara>
    Com o PHP-GTK você pode registrar mais de uma função para ser chamada 
	quando um sinal é emitido por um widget. Ito permite à você configurar 
	uma série de funções para serem chamadas em respsta à uma ação experada.
   </simpara>
   <para>
    Quando mais de uma função é conectada à um sinal, as funções são chamadas 
	na ordem em que foram registradas quando aquele sinal é emitido.
    <example>
     <title>Ordem do Sinal da Callback</title>
     <programlisting role="php">
<![CDATA[
<?php
dl('php_gtk.' . (strstr(PHP_OS, 'WIN') ? 'dll' : 'so')) ||
die("Não foi possível carregar o módulo!\n");

function primeira($botao) 
{
    print "Primeira função foi chamada.\n";
}

function segunda($botao) 
{
    print "Segunda função foi chamada.\n";
}

$janela = &new GtkWindow();
$janela->connect_object("destroy", array("gtk", 
"main_quit"));

$botao = &new GtkButton("Clique Me!!");
$botao->connect("clicked","primeira");
$botao->connect("clicked","segunda");
$janela->add($botao);

$janela->show_all();

gtk::main();

?>
]]>
     </programlisting>
    </example>
	No exemplo acima nós conectamos duas funções para o sinal 
	<signalname>clicked</signalname> de um botão. À primeira chamada 
	ao método <function class="GtkObject">connect</function> conecta 
	o sinal <signalname>clicked</signalname> à função <literal>primeira()</literal>, 
	a segunda chamada ao sinal <signalname>clicked</signalname> conecta-se à função 
	<literal>segunda()</literal>.
   </para>
   <para>
    A saída para este programa seria:
    <screen>
Primeira funþÒo foi chamada.
Segunda funþÒo foi chamada.
    </screen>
   </para>
  </sect2>
 </sect1>
 
 <sect1 id="signals.custom.params">
  <title>Usando Parâmetros Personalizados</title>
  <sect2 id="signals.custom.data">
   <title>Passando dados personalizadso como parâmetro</title>
   <simpara>
    Quando se está <link linkend="signals.connection">conectando</link> sinais, 
	é possível adicionar um parâmetro personalizado adicional para à callback. 
	Isto é útil quando se quer passar um objeto que você quer usar para executar 
	uma ação, para a sua função de callback.
	<!-- difícil de traduzir, ficou bom?
    When <link linkend="signals.connection">connecting</link> signals,
    it is possible to add an extra custom parameter to the callback.  This
    is useful for passing the object you want to perform an action on, to
    your callback function.-->
   </simpara>
   <simpara>
    Por eemplo, quando um botão é pressionado nós podemos destruir a instância 
	pai da <classname>GtkWindow</classname> à qual uma instância de <classname>GtkButton</classname> 
	pode <function class="gtkcontainer">adicionada</function>.
	<!-- credi :/
    For example, when a button is pressed we might want to destroy the parent
    instance of <classname>GtkWindow</classname> that that instance of
    <classname>GtkButton</classname> has been 
    <function class="gtkcontainer">add</function>ed to. -->
   </simpara>
   <simpara>
    Você pode fazer isto incluindo um terceiro parâmetro adicional à chamada do 
	método <function class="GtkObject">connect</function>. Este terceiro parâmetro 
	será passado para o seu manipulador de sinal de sua função  como sendo 
	o último parâmetro da callback.
	<!-- nossa, difícilimo hehe: _)
    You can do this by including an optional third parameter to the 
    <function class="GtkObject">connect</function> call. This will then be
    passed to your signal handler function as the final callback parameter.-->
   </simpara>
   <para>
    <example>
     <title>
	  Usando parâmetros personalizados com o método
      <function class="GtkObject">connect</function>.
     </title>
     <programlisting role="php">
<![CDATA[
<?php
dl('php_gtk.' . (strstr(PHP_OS, 'WIN') ? 'dll' : 'so')) ||
die("Não foi possível carregar o módulo!\n");

function botao_clicado($botao, $janela) 
{
    $janela->destroy();
    gtk::main_quit();
}

$janela = &new GtkWindow();

$botao = &new GtkButton("sair");
$botao->connect("clicked","botao_clicado", $janela);

$janela->add($botao);
$janela->show_all();

gtk::main();

?>
]]>
     </programlisting>
    </example>
	No código acima você pode ver que nós passamos não somente a 
	variável <literal>$botao</literal>, uma instância da classe 
	<classname>GtkButton</classname>,  para o sinal <signalname>clicked</signalname> 
	mas também passamos a variável <literal>$janela</literal>, uma instância da classe 
	<classname>GtkWindow</classname>. Isto permite à nós chamar o método 
	da janela <function class="GtkObject">destroy</function>.
   </para>
   <note>
    <simpara>
	 Você pode ter quantos parâmetros personalizados desejar.
    </simpara>
   </note>
   <para>
    Ao passar a variável <literal>$botao</literal> como parâmetro objeto da chamada 
	e a variável <literal>$janela</literal> como sendo nosso parâmetro personalizado, 
	nós podemos usar a mesma callback para mais de um <classname>GtkButton</classname> 
	em mais de uma <classname>GtkWindow</clssname>. Note que os nomes dados aos 
	parâmetros junto com a callback são irrelevantes fora da função de callback; 
	o PHP-GTk escolhe as posições dos parâmetros nas chamadas ao método connect* e 
	passa estas variáveis listadas na declaração da callback como sendo arrays, para 
	que qualquer instância da conexão usando a mesmo estrutura de parâmetro possam usar 
	a mesma callback. Isto é demonstrado no código abaixo usando um único parâmetro 
	personalizado, mas é igualmente válido para mais de um.
	<!-- se alguém quiser consertar, tem alguns errinhos de concordância:
    By passing the <literal>$button</literal> variable as our calling object
    parameter and the <literal>$window</literal> variable as our custom
    parameter, we could use this same callback for more than one
    <classname>GtkButton</classname> on more than one
    <classname>GtkWindow</classname>.  Note that the names given to the
    parameters within the callback are irrelevant outside the callback
    function; PHP-GTK picks up on the positions of the parameters in the
    connect* method calls and passes these to the variables listed in the
    callback declaration as an array, so that any instance of a connection
    using the same parameter structure can use that same callback.  This is
    demonstrated in the code below using a single custom parameter, but is
    equally true for more than one.-->
    <example>
     <title>Usando a mesma callback para mais de uma janela</title>
     <programlisting role="php">
<![CDATA[
<?php
dl('php_gtk.' . (strstr(PHP_OS, 'WIN') ? 'dll' : 'so')) ||
die("Não foi possível carregar o módulo!\n");

function botao_clicado($botao, $janela)
{
    $janela->set_title("entitulada");
}

$janela1 = &new GtkWindow();
$janela1->connect_object("destroy", array("gtk", "main_quit"));
$janela2 = &new GtkWindow();
$janela2->connect_object("destroy", array("gtk", "main_quit"));

$botao1 = &new GtkButton("clique em mim");
$botao2 = &new GtkButton("ou em mim");

$botao1->connect("clicked", "botao_clicado", $janela1);
$botao2->connect("clicked", "botao_clicado", $janela2);

$janela1->add($botao1);
$janela2->add($botao2);

$janela1->show_all();
$janela2->show_all();

gtk::main();

?>
]]>
     </programlisting>
    </example>
   </para>
  </sect2>
 
  <sect2 id="signals.connect.object">
   <title>Usando o método connect_object*</title>
   <para>
    Ambos <function class="GtkObject">connect_object</function> e 
    <function class="GtkObject">connect_object_after</function> permitem à você 
	passar um objeto diferente do objeto que está sendo chamado como primeiro 
	parâmetro da sua função callback. Isto é muito usado para chamar funções 
	estáticas do PHP-GTK, como (por exemplo) a função <function>gtk::main_quit</function>:
    <example>
     <title>
	  Usando o método <function class="GtkObject">connect_object</function> 
	  para especificiar uma função embitida como sendo uma função de callback.
     </title>
     <programlisting role="php">
<![CDATA[
<?php
dl('php_gtk.' . (strstr(PHP_OS, 'WIN') ? 'dll' : 'so')) ||
die("Não foi possível carregar o módulo!\n");

$janela = &new GtkWindow();
$janela->connect_object("destroy", array("gtk", "main_quit"));
$janela->show();

gtk::main();

?>
]]>
     </programlisting>
    </example>
	Isto também poderia ser feito chamando qualquer função estática ou 
	método usando a sintaxe de expressão (array) <literal>gtkobject::method</literal>.
	<!-- fácil de entender, difícil de traduzir :/
    This could be called on any static function or method by using the
    <literal>gtkobject::method</literal> syntax expressed as an array.-->
   </para>
   <para>
    Isto também significa que você pode ter uma callback para múltiplos sinais. 
	Por exemplo; você pode criar uma janela contendo (desde que contenha os widgets 
	e containers necessários) um <classname>GtkMenuBar</classname>, uma 
	<classname>GtkToolbar</classname> e um <classname>GtkButton</classname>. 
	Quando <literal>Sair</literal> é escolhido pelo usuário dentre um desses 
	widgets, uma função de "desligamento" pode ser invocada passando uma instância 
	de <classname>GtkWindow</classname> como primeiro parâmetro, permitindo que a 
	janela possa ser destruída de qualquer uma das conexões. A função de callback 
	e as conexões nesta instância podem ser parecidas com esta:
    <example>
     <title>
	  Usando o método <function class="GtkObject">connect_object</function> 
	  para passar outro objeto como primeiro parâmetro.
     </title>
     <programlisting role="php">
<![CDATA[
<?php
dl('php_gtk.' . (strstr(PHP_OS, 'WIN') ? 'dll' : 'so')) ||
die("Não foi possível carregar o módulo!\n");

function destruir_janela($janela)
{
    $janela->destroy();
    gtk::main_quit();
}

$janela = &new GtkWindow();
$botao_sair = &new GtkButton("Sair");
$botao_sair->connect_object("clicked", "destruir_janela", $janela);
$janela->add($botao_sair);
$janela->show_all();

gtk::main();
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    O método connect_after* permite que os callbacks "rodem após" 
	o evento do sinal padrão. Isto pode ser muito útil em algumas situações; 
	por exemplo, onde você quer destriuir somente uma das muitas janelas em 
	uma dada circunstância. Entretanto, o método connect_after* somente 
	irão funcionar quando o sinal for criado no código fonte GTK usando a 
	flag <literal>GTK_RUN_LAST</literal>. O sinal <signalname>destroy</signalname> 
	e todos os sinais <literal>'evento'</literal> tem esta flag; além dela 
	o único jeito de fazer esta verificação é testar o sinal usando o PHP-GTK ou 
	lendo o código fonte do GTK.
	<!-- difícil
    The connect_after* methods allow callbacks to be "run after"
    the default signal handler for that signal.  This can be useful
    in some situations; for example, where you want to destroy only one of
    several windows in a given circumstance.  However, connect_after* methods
    will only work when a signal has been created in the GTK source with a 
    <literal>GTK_RUN_LAST</literal> flag.  The 
    <signalname>destroy</signalname> signal and all the
    <literal>'event'</literal> signals have this flag; beyond that,
    the only way to check is to either test the signal within PHP-GTK or
    read the GTK source. -->
    <example> 
     <title>Usando o método 
      <function class="GtkObject">connect_after</function>.
     </title>
     <programlisting role="php">
<![CDATA[
<?php
dl('php_gtk.' . (strstr(PHP_OS, 'WIN') ? 'dll' : 'so')) ||
die("Não foi possível carregar o módulo!\n");

function rotina_sair($janela) 
{
    print("Desligando...\n");
    gtk::main_quit();
}

$janela1 = &new GtkWindow();
$janela1->set_title("Sair do loop principal");
$janela1->connect("destroy", "rotina_sair");

$janela2 = &new GtkWindow();
$janela2->set_title("Destruir esta janela");
$janela2->connect_after("destroy", "rotina_sair");

$janela1->show();
$janela2->show();

gtk::main();

?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Veja também: <classname>GtkObject</classname>, 
    <function class="GtkObject">connect_after</function>
    <function class="GtkObject">connect_object</function> e 
    <function class="GtkObject">connect_object_after</function>.
   </simpara>
  </sect2>
 </sect1>

 <sect1 id="signals.events">
  <title>Sinais e Eventos</title>
  <simpara>
   <emphasis>Sinais GTK, Eventos GDK.</emphasis>
  </simpara>
  <simpara>
   Sinais não são eventos, e eventos não são sinais. Um sinal é uma mensagem 
   emitida pela instância de um <classname>GtkObject</classname> em resposta à 
   algum elemento pré-determinado em seu ambiente (programa), ex: uma ação feita 
   pelo usuário final, ou uma instrução de um método ou função. Sinais são sempre 
   programados no código, internamente dentro do GTK ou externamento pelo programador 
   PHP-GTK.
  </simpara>
  <simpara>
   Eventos, por outro lado, são um circuito continuo dos impulsos que 
   enviam mensagens a respeito das mudanças no ambiente (programa) nos 
   sistemas de janelas. O loop principal do GTK é feito através deste 
   circuito de evnetos, e uma série de outras coisas.
   <!-- fiocu muito ruim:/ melhoras?
   Events, on the other hand, are a continual stream of impulses
   communicating messages concerning environmental changes in the underlying
   windowing system.  The GTK main loop is made up of this stream of events, 
   among other things.-->
  </simpara>
  <note>
   <simpara>
    não é possível conectar uma função de callback à um 
    <classname>GdkEvent</classname> diretamente.
   </simpara>
  </note>
  <simpara>
   Qualquer widget que tenha sua própria <classname>GdkWindow</classname> 
   pode capturar eventos que são relevantes à ela. Widgets falham na 
   <classname>GdkWindow</classname> - aquelas criados com a flag 
   <literal>GTK_NO_WINDOW</literal> - não podem fazer isso, à não ser que 
   eles tenham um <classname>GtkEventBox</classname> - um widget 
   criado para este propósito específico. Há ocasiões quando é útil poder 
   capturar eventos; um exemplo óbvio seria a criação de um <classname>GtkToolTips</classname> 
   que é provocado quando o widget captura o evento <literal>GDK_ENTER_NOTIFY</literal> 
   e destruído quando o mesmo widget captura o evento <literal>GDK_LEAVE_NOTIFY</literal>.
	<!-- ficou bom?
   Any widget having its own <classname>GdkWindow</classname> may capture
   events that are relevant to it.  Widgets lacking a 
   <classname>GdkWindow</classname> - those created with the 
   <literal>GTK_NO_WINDOW</literal> flag - cannot do so, unless they are
   housed within a <classname>GtkEventBox</classname> - a widget created for
   this specific purpose.  There are occasions when it is useful to be able
   to capture events; one obvious example would be the creation of an instance
   of <classname>GtkToolTips</classname> which is triggered when its subject
   widget captures the <literal>GDK_ENTER_NOTIFY</literal> event and
   destroyed when the same widget captures the
   <literal>GDK_LEAVE_NOTIFY</literal> event. -->
  </simpara>
  <simpara>
   Entretanto não é possível usar um evento para chamar uma callback do mesmo 
   modo como é feito com o sinal, há uma série de sinais derivados da classe 
   <classname>GtkWidget</classname> conhecidos como <literal>sinais 'evento'</literal>. 
   Estas são maneiras eficientes de descriar um evento em termos de sinal, permitindo 
   que callbacks sejam provocados diretamente através da captura de ocorrências da 
   maioria dos <enumname>GdkEventTypes</enumname>. O objeto <classname>GtkTooltips</classname> 
   usa o método <function class="GktObject">connect_object</function> e o sinal genérico 
   (<signalname>evento</signalname>) a fim de monitorar o widget.
   <!-- mais ou menos, mas dá pra enganar :)
   Although it is not possible to use an event to trigger a callback in the
   same way as a signal, there are a series of signals derived from 
   <classname>GtkWidget</classname> collectively known as 
   <literal>'event' signals</literal>.  These are effectively ways
   of describing an event in terms of a signal, allowing callbacks to be
   indirectly triggered through a captured occurrence of most of the 
   <enumname>GdkEventTypes</enumname>. The 
   <classname>GtkTooltips</classname>  object itself uses the 
   <function class="GktObject">connect_object</function> method and the
   generic <signalname>event</signalname> signal in order to monitor its
   subject widget.-->
  </simpara>
  <para>
   O conceito de eventos não é muito fácil. Por favor copie, cole e rode 
   o script a seguir a fim de ter uma idéia do que são eventos em um wiget 
   quando estão em ação.
   <example>
    <title>Demonstração do fluxo de eventos usando a classe 
     <classname>GtkButton</classname>
    </title>
    <programlisting role="php">
<![CDATA[
<?php
dl("php_gtk." . (strstr(PHP_OS, "WIN") ? "dll" : 
"so")) ||
die("Não foi possível carregar o módulo!\n");

function mostrar_tipo_de_evento($botao, $evento, $texto) 
{
    $tipo_de_evento = $evento->type;
    $texto_a_inserir = $texto->get_length();
    $texto->freeze();
    switch($tipo_de_evento) {
      case 2:
        $texto->insert_text("GDK_EXPOSE\n", $texto_a_inserir);
      break;
      case 3:
        $texto->insert_text("GDK_MOTION_NOTIFY\n", $texto_a_inserir);
      break;
      case 4:
        $texto->insert_text("GDK_BUTTON_PRESS\n", $texto_a_inserir);
      break;
      case 5:
        $texto->insert_text("GDK_2BUTTON_PRESS\n", $texto_a_inserir);
        $botao->hide();
      break;
      case 7:
        $texto->insert_text("GDK_BUTTON_RELEASE\n", $texto_a_inserir);
      break;
      case 8:
        $texto->insert_text("GDK_KEY_PRESS\n", $texto_a_inserir);
      break;
      case 9:
        $texto->insert_text("GDK_KEY_RELEASE\n", $texto_a_inserir);
      break;
      case 10:
        $texto->insert_text("GDK_ENTER_NOTIFY\n", $texto_a_inserir);
      break;
      case 11:
        $texto->insert_text("GDK_LEAVE_NOTIFY\n", $texto_a_inserir);
      break;
      case 12:
        $texto->insert_text("GDK_FOCUS_CHANGE\n", $texto_a_inserir); 
      break;
      case 14:
        $texto->insert_text("GDK_MAP\n", $texto_a_inserir);
      break;
      case 15:
        $texto->insert_text("GDK_UNMAP\n", $texto_a_inserir);
        $botao->destroy();
		$amarelo = &new GdkColor("#FFFFFF");
		$preto = &new GdkColor("#000000");
        $texto->insert(NULL, $amarelo, $preto, 
"
\n* EVENTOS DO GDK E SINAIS DO GTK - stream de fundo vs mensagens de primeiro plano *
\n
* A maioria dos GdkEventTypes fazem parte dos sinais do GTK, conhecidos como sinais do 'evento', implementados na GtkWidget. Os tipos que aparecem na tela estão lá porque o GtkButton foi programado para emitir o sinal genérico 'evento' cada vez que ele capturar um dos eventos stream do GDK que são feitos no loop principal do GTK. Em qualquer um dos casos, o GdkEvent foi passado como sendo um parâmetro de callback sendo assim que ele pode ser ter os valores dos seus tipos numerado para que a função possa tratá-los. Veja acima uma série de valores de eventos que foram capturados durante sua recente interação com o widget GtkButton. *
\n
* Por favor, note que a maioria dos sinais do GTK NÃO correspondem aos eventos GDK nem aqui nem em nenhuma outra maneira! Por exemplo, o sinal de conexão \$botao->connect('pressed', 'qualquer_coisa'); não tem relação com o evento GDK_BUTTON_PRESS que é gerado, que no caso, refere-se ao botão do mouse ativiado e não ao sinal 'pressed' do GtkButton. *
\n
");
      break;
    }
    $texto->thaw();
    return false;
}

$janela = &new GtkWindow();
$janela->set_position(GTK_WIN_POS_CENTER);
$janela->set_default_size((gdk::screen_width()/1.5), (gdk::screen_height()-20));
$janela->connect_object("destroy", array("gtk", "main_quit"));
$janela->realize();

$caixa = &new GtkVBox(false, 5);
$janela->add($caixa);
$scrljan = &new GtkScrolledWindow();
$caixa->pack_start($scrljan, true, true, 0);
$texto = &new GtkText();
$scrljan->add($texto);

$botao = &new GtkButton("Clique aqui duas vezes para obter informações..");
$botao->add_events(GDK_ALL_EVENTS_MASK);
$botao->connect("event", "mostrar_tipo_de_evento", $texto);
$caixa->pack_end($botao, false, false, 5);

$janela->show_all();

gtk::main();

?>
]]>
    </programlisting>
   </example>
  </para>
 </sect1>
<!--
why we cannot choose the position in the insert() method i don't know, beucase 
in the manual it's say that we have more "control" over the text :)

creio que isto possa ser melhorado em muito:
"\n* GDK EVENTS AND GTK SIGNALS - background stream vs foreground 
messaging *
\n
* Most GdkEventTypes have counterpart GTK signals, known as 'event'
  signals, implemented in GtkWidget.  The types on your screen are there
  because the GtkButton was programmed to emit the generic 'event' signal
  each time it captured one of the stream of GDK events that makes up the
  GTK main loop.  In each case, the captured GdkEvent was passed as a
  callback parameter so that its enumerated type value could be determined
  within the signal handler function.  Scroll down to see the series of event
  values captured during your recent interaction with the GtkButton widget. *
\n
* Please note that the majority of GTK signals do NOT correspond to GDK
  events in this or any other way!  For example, the signal connection
                      \$button->connect('pressed', 'whatever');
  has no relationship to the GDK_BUTTON_PRESS event it generates, which
  refers to mouse-button activity and not to the GtkButton 'pressed' signal. *
\n" -->
</chapter>
